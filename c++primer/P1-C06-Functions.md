# 总结

如何定义和声明函数

[toc]

# 1.函数基础*

函数(**function**)是一个有名字的代码块

## 基础

### 函数定义

函数定义

* 组成部分有: 返回类型(**return type**), 函数的名字(**name**), 由0个或多个形参(**parameter**)组成的列表以及函数体(**function body**).

  * 形参列表: 形参位于一对圆括号之内,并以逗号分隔
  * 函数体: 函数的语句块, 其中是调用函数时被执行的语句

* 形式:

  ```c++
  return_type name(parameters_list) 
  {
      /*function body*/
  }
  ```

* 例子

  ```c++
  //to determine the factorial of a given number
  int fact(int val)		
  {
      int ret = 1;
      while (val > 1)
          ret *= val--;
      return ret;
  }
  ```

### 函数调用

调用运算符`()`: 

* 作用: 通过调用运算符(**call operator**)来执行函数, 该过程称为函数调用(**function call**)
* 用法: `name(expr_list)`

  * `name`操作数可以是函数或指向函数的指针
  * `expr_list`是用逗号隔开的实参(**argument**)列表; 实参用于初始化函数的形参
* 具体动作:

  1. 使用实参列表中的实参来初始化相应的形参

  2. 将控制转换到给定的函数; 因此主调函数(**calling function**)的执行被挂起, 被调函数(**called function**)的执行开始.
* 结果: 
  * 函数的返回类型为`void`时, 表达式没有结果
  * 函数的返回类型不是`void`时, 其值是函数返回的值, 其类型是函数的返回类型
    * 返回类型是引用类型时, 结果是左值
    * 返回类型不是引用类型时, 结果是右值

函数的执行过程

1. (隐式地)定义,并初始化它的形参; 这是调用表达式完成的工作
2. 执行函数体的语句, 直至遇到`return`语句;
3. 执行`return`语句; `return`语句完成的动作:
   1. 返回`return`语句中的值(如果有的话), 也就是使用该值初始化调用表达式的结果
   2. 把控制从被调函数转换到主调函数

### 形参和实参

实参(**arguments**), 是一个函数的形参(**parameters**)的初始符;

* 实参初始化对应位置的形参
  * 实参列表的第一个实参初始化形参列表的第一个形参, 第二个实参初始化第二个形参, 以此类推
  * **标准没有规定实参的求值顺序; 编译器能以任意顺序对实参求值**
* 实参的类型必须与对应位置的形参类型匹配; 即两者类型相同, 或者实参类型能够转换成形参类型
* 实参的数量必须和形参的数量一致

### 函数形参列表

* 形参列表可以为空, 但不能省略; 为了与C语言兼容, 可以使用关键字`void`表示空列表

  ```c++
  void f1() {/*...*/}
  void f2(void) {/*...*/}
  ```

* 形参列表中的形参通常用逗号隔开; 每个形参都是含有一个声明符的声明

  ```c++
  int f3(int v1, v2) {/*...*/} 		//error
  int f4(int v1, int v2) {/*...*/}	//ok
  ```

* 形参的名字是可选的; 但是无法使用未命名的形参.
* 形参的名字不能相同
* 在函数的最外层作用域中的局部变量的名字不能与形参的名字相同

### 函数返回类型

* 大多数类型都能用作函数的返回类型; 一种特殊的返回类型是`void`, 表示函数不返回任何值
* 不能用作返回类型的类型
  * 数组类型
  * 函数类型(**function type**)

## 1.1局部对象*

两个重要的概念

* 名字的作用域, 是指程序的部分文本, 名字在其中是可见的

* 对象的生命周期/寿命(**lifetime**), 是指程序执行过程中该对象存在的一段时间

在块作用域中定义的形参和变量, 被称为局部变量(**local variable**)/局部对象(**local object**); 

* 局部变量隐藏名字在外层作用域中的声明
* 局部变量的寿命取决于它如何定义的

在所有块作用域外定义的对象, 在整个程序执行过程中一直存在;

### 自动对象

自动对象(**automatic object**): 只在块执行时才存在的对象

* **普通局部变量**所对应的对象, 当函数的控制流经过变量定义时被创建, 当控制到达所在的块末尾时被销毁
* 当一个块执行结束后, 在该块中创建的自动对象的值是未定义的
* 自动对象没有初始符时, 执行默认初始化.
* 例子: 函数的形参是自动对象

### 局部静态对象

局部静态对象(**local static object**): 

* 局部静态对象在程序的执行路径**第一次**经过对象定义语句时初始化 并直到**程序终止**才被销毁
* 定义: `static`作用于基本类型, 如`static int i = 0;`
* 局部静态对象没有初始符时, 执行值初始化.

## 1.2函数声明*

* 函数的名字必须在使用之前声明; 

* 函数只能定义一次, 但可以声明多次.
* 除了一个例外情况(s15.3 p603), 我们可以声明一个还没定义的函数, 只要永远不使用该函数

函数声明, 也称为函数原型(**function prototype**)

* 返回类型, 函数名, 形参类型这三个元素描述了函数的接口

* 形式: `return_type name(paremeter_type);`

  * 声明中的形参可以省略名字,  不能省略类型

* 例子

  ```c++
  void print1(vector<int>::const_iterator beg,
            vector<int>::const_iterator end);
  void print2(vector<int>::const_iterator,
            vector<int>::const_iterator);
  ```

建议: 在头文件中进行函数声明

* 函数最好是在头文件中声明, 在源文件中定义

## 1.3分离式编译*

分离式编译(**separate compile**), 允许我们把程序分割成几个文件, 而且每个文件可以独立编译.

* 大多数编译器提供分离式编译每个源文件的机制, 这一过程通常会产生包含对象代码(**object code**)的对象文件(**object file**), 文件后缀是`.obj`(Windows)或`.o`(UNIX).
* 编译器可以把对象文件链接(**link**)在一起形成可执行文件(**executable file**)
* 要生成可执行文件(**executable file**), 必须告诉编译器所有用到的代码在哪里; 

# 2.实参传递*

每次调用函数都会创建形参, 并用传入的实参对形参初始化; 

形参初始化的过程与变量初始化一样

* 当形参是引用类型时, 形参绑定到对应的实参; 此时, 实参被引用传递(**passed by reference**), 函数被传引用调用(**called by reference**)
* 当形参是非引用类型时, 形参拷贝对应实参的值; 此时, 实参被值传递(**passed by value**), 函数被传值调用(**called by value**)

## 2.1值传递Passing Arguments by Value*

与初始化非引用类型的变量一样, 值传递一个实参, 就是拷贝实参的值并把该值初始化相应的形参

* 这里的形参和实参是两个相互独立的对象; 因此对形参做的所有操作都不会影响实参

* 指针类型的形参
  * 对应的实参被值传递; 因为是指针类型, 该形参可以间接访问它所指的对象, 可以修改它所指对象的值(如果所指对象不是`const`)

## 2.2引用传递Passing Arguments by Reference*

与初始化引用类于的变量一样, 引用传递一个实参, 就是把形参绑定到相应的实参对象

* 在这里, 对形参进行操作, 实际上是对形参所指的对象进行操作

引用形参的几点作用

* 使用引用形参以避免拷贝
  * 大型容器或大型类类型的对象的拷贝是比较低效的; 
  * 某些类型不支持拷贝操作
* 使用引用形参以返回额外信息
  * 一个函数只能返回一个值;
  * 如果需要返回多个值时, 其中一种方法是: 给函数传入引用实参, 用于保存额外的需要返回的值. 

## 2.3`const`形参和实参*

和变量的初始化过程一样, 关于`const`的规则有

* 可忽略实参的顶层`const`, 即实参可以是`const`, 也可以是非`const`;
  * 由于上面的性质, 形参有没有顶层`const`, 尽管形式上有差异, 但并不会让形参列表有明显的区别; 所以, 在定义重载函数时, 顶层`const`也是可忽略的

	```c++
  void fcn(const int i) {/*...*/}
  void fcn(int i) {/*...*/}		//error: 拥有相同的形参列表
  ```

* 不能忽略实参的底层`const`
* 非`const`可转换成`const`, 反之不然

指针或引用形参和`const`(p213)

* 如果可能, 使用指向`const`的指针或引用形参; 因为指向非`const`的指针或引用形参会极大地限制了函数所能接受的实参类型.
  * 指向非`const`的引用形参, 不能接受的实参有: 字面值, 表达式, 需要转换的对象, `const`对象
  * 指向非`const`的指针形参, 不能接受的实参有: 字面值, 表达式, 指向`const`的指针 

## 2.4数组形参

数组的两个特殊性质

* 不支持拷贝操作; 因此, 不能值传递数组
* 当使用数组时会将其转换成指针; 因此, 传递数组时实际上传递一个指针

把形参写成类似数组类型的形式, 实际上等于指针类型

```C++
//尽管形式不同, 但这三个函数声明是等价的, 都有一个const int*类型的形参
void print(const int*);
void print(const int[]);	// 函数的意图是作用于一个数值
void print(const int[10]);	// 这里的维度表示数值最好含有多少元素; 维度不影响类型
```

由于数组是以指针的形式传递给函数的, 函数不能从该实参中知道数组的尺寸; 函数需要调用者提供额外的信息, 有三种常用的技术

* 使用标记指明数组的长度: 
  * 在数组中包含一个表示结尾的标记, 如C风格字符串中的空字符
* 使用标准库规范:
  * 使用两个指针, 一个指向首元素, 一个指向尾后
* 使用一个表示数值大小的形参

多维数组类型的形参

* 多维数组是数组的数组, 所以其元素是数组类型
* 如上述那样, 传递数组时实际上传递一个指针; 对于多维数组, 该指针是一个指向数组的指针; 所以数组第二维(以及后面所有维度)的大小都是数组类型的一部分, 不能省略.

数组引用类型的形参: 

* 数组引用类型的形参绑定到数组类型的实参; 不是指针类型

* 因为数组的维度是类型的一部分
  * 可以从该形参中得到数组的维度
  * 但只能接受这种数组类型的实参; 维度也要一样

## 2.5`main`函数的形参: 处理命令行选项 

有时需要给`main`传递实参, 一种最常见情景是: 让用户设置一组选项来确定程序要执行的操作.

`main`函数有两个(可选的)形参:

* 第一个形参是`int`类型; 

* 第二个形参是`char **`类型; 相应的实参

  ```c++
  int main(int argc, char **argv) {...}
  int main(int argc, char *argv[]) {...}	//char *argv[] 等于 char **argv
  ```

传给`main`函数的实参: 从命令行传来的

* 第一个实参`argc`是第二个实参`argv`所表示的数组的维度

* 第二个实参 `argv`是一个数组, 其元素是指向C风格字符串的指针;

  * 第一个元素要么指向程序的名字, 要么指向一个空字符串; 
  * 后面的元素依次是命令行中提供的字符串. 
  * 尾后位置存在一个值为0的元素.

* 例子:

  ```c++
  prog -d -o ofile data0
  ```

  * 假设有一个可执行文件`prog`; 在命令行中输入以上指令

  * 此时程序中`main`函数的`argc`等于5, `argc`包含如下的C风格字符串

    ```C++
    argv[0] = "prog";  //也可能是一个空字符串
    argv[1] = "-d";
    argv[2] = "-o";
    argv[3] = "ofile";
    argv[4] = "data0";
    argv[5] = 0;
    ```

## 2.6可变形参

### `initializer_list`形参(C++11)

C++11提供了两种方法来编写能处理不同数量实参的函数

* 如果所有实参的类型相同, 使用`initializer_list`标准库类型
* 如果实参类型不同, 可以编写一种特殊的函数, 叫做可变参数模板. (见s16.4 p699)

`initializer_list`类型: 是一种模板类型, 表示一组指定类型的值

* 对象的元素数量可以是零个或多个

* 该类型的对象中的元素永远是`const`的; 一旦初始化, 无法改变元素的值

* 支持的操作

  | 操作                                     | 描述                                   |
  | ---------------------------------------- | -------------------------------------- |
  | `initializer_list<T> lst;`               | 默认初始化;`T`类型元素的空列表         |
  | `initializer_list<T> lst{a, b, c, ...};` | 列表初始化; 列表中的元素是`const`      |
  | `lst2(lst)`                              | 拷贝操作; 不拷贝元素, 两个对象共享元素 |
  | `lst2 = lst`                             | 赋值操作;不拷贝元素, 两个对象共享元素  |
  | `lst.size()`                             | 列表中的元素数量                       |
  | `lst.begin()`                            | 返回指向首元素的指针                   |
  | `lst.end()`                              | 返回指向尾后元素的指针                 |

`initializer_list`形参

* 给`initializer_list`形参传递值的序列时, 必须把序列放在一对花括号内

* 例子

  ```c++
  void error_msg(initializer_list<string> il);
  string s = "expected";
  error_msg({"functionX", s, "okay"});
  ```

### 省略符形参Ellipsis Parameters

背景

* 在C语言中, C标准库功能`varargs`提供了省略符, 用于传递不定数目的实参.

* C++继承了省略符, 以便于C++程序能够访问使用省略符的代码

省略符形参

* 注意
  * 除了与C代码交互外, 省略符形参不应该用于其他目的.
  * 省略符形参应该仅用于C和C++通用的类型; 大多数类类型的对象在传递给省略符形参时都无法正确拷贝

* 用法: 只能出现在形参列表的最后一个位置; 有两种形式

  ```c++
  void foo(parm_list, ...);
  void foo(...);
  ```

  * 第一种形式
    * 先指定了`foo`函数的部分形参的类型; 编译器会对这部分的实参执行类型检查
    * 然后是可选的逗号加上省略符`...`; 编译器不会(也没有必要)对此进行类型检查
  * 第二种形式
    * 一个省略符; 编译器不会(也没有必要)对此进行类型检查

# 3.返回类型和`return`语句

`return`语句: 

* 动作: 终止当前正在执行的函数并将控制返回到调用者(caller)处

* 用法: 返回值类型必须与相应函数的返回类型匹配

  ```c++
  return;
  return expression;
  ```

  * 第一种形式没有值; 与`void`返回类型匹配
  * 第二种形式返回`expression`的结果; `expression`可以是表达式, 变量, 函数等

## 3.1无返回值的函数*

返回类型为`void`的函数: 无返回值的函数, `void`类型表示没有返回值

* 没有值的`return`语句只能在该类函数中使用
* 当`expression`的结果为`void`时, 可以使用第二种形式的`return`语句
  * 即`expression`是一个`void`返回类型的函数时
* 该类函数不要求非得有`return`语句; 因为在函数体中的最后一句后面会隐式地执行一个`return`语句.

## 3.2有返回值的函数*

返回类型不是`void`的函数: 有返回值的函数

* 除了`main`函数, 该类函数必须返回一个值, 因此`return`语句必须使用第二种形式的`return`语句

* `return`语句返回值的类型必须与函数的返回类型匹配: 类型相同, 或能隐式地转换成函数的返回类型

编译器试图确保: 具有返回值的函数只能通过一条有效的`return`语句退出; 但是很多编译器无法保证顾及所有情况. 如

```c++
bool str_subrange(const string &str1, const string &str2)
{
    //大小相同的情况
    if (str1.size() == str2.size())
        return str1 == str2;//ok: 返回布尔值
    //得到较短string对象的大小
    auto size = (str1.size() < str2.size())
        		? str1.size() : str2.size();
    //检查两个string对象的对应字符是否相等
    for (decltype(size) i = 0; i != size; ++i) {
        if (str1[i] != str2[i])
            return;			//error#1: 没有返回值;编译器将报告这错误
    }
    //error#2:控制流可能会到达函数的末尾并且没有遇到return语句就结束执行
    //编译器可能检查不出这一错误
}
```

### 值是如何返回的

返回一个值的过程: 

* 调用函数的地方创建一个临时量, 用于保存函数调用的结果
* 返回值初始化该临时量

因此, 初始化规则适用于返回值的过程: 要特别注意函数返回局部对象的情况

* 不要返回指向局部对象的引用或指针
  * 当函数完成后, 它所占用的空间被释放掉, 包括它的局部对象; 此时, 局部对象的引用或指针指向一个不存在的对象.

### 返回值与列表初始化(C++11)

C++11标准中, 函数可以返回一个花括号括起的值列表; 与普通的`return`语句一样, 该列表对表示函数返回的临时量进行初始化. 特别的, 若该列表为空, 临时量进行值初始化.

### `main`的返回值

`main`函数允许终止时没有`return`语句;

* 如果控制到达`main`的结尾处而且没有`return`语句, 编译器隐式地插入一条返回0的`return`语句

`main`函数的返回值用作状态指示符

* 返回0, 表示执行成功
* 返回非零值, 表示执行失败; 非零值的具体含义依机器而定

为了使代码与机器无关, `cstdlib`头文件定义两个预处理器变量;

* `EXIT_FAILURE`, 表示执行成功
* `EXIT_SUCCESS`, 表示执行失败

### 递归Recursion

递归函数: 直接或间接调用它自身的函数

* `main`函数不能调用它自己

* 例子

  ```c++
  //计算val的阶乘
  int factorial(int val)
  {
      if (val > 1)
          return factorial(val-1) * val;
      return 1;
  }
  ```

在递归函数中, 一定有某条路径是不包含递归调用的; 否则, 函数将不断地调用它自身直到程序栈空间耗尽为止. 这样的函数被称含有递归循环(**recursion loop**)

## 3.3复杂的返回类型

### 声明一个返回数组指针的函数

* 函数的返回类型不能是数组类型, 因为数组不支持拷贝操作; 不过, 函数可以返回指向数组的指针或引用

* 形式: `Type (*function(parameter_list))[dimension]`
  * `Type`是数组元素的类型
  * `dimension`是数组的维度
  * 包围`(*function(parameter_list))`的圆括号是必要的; 因为`[]`比`*`先修饰类型
* 例子:`int (*func(int i))[10];`
* 说明
  * 可以使用类型别名来简化声明

### 尾置返回类型**Trailing Return Type**(C++11)

* 形式: `auto name(parameter_list) -> type`
  * `auto`表示使用尾置返回类型
  * 在形参列表后跟`->`和返回类型
* 例子:`auto func(int i) -> int(*)[10];`

### `decltype`与返回类型

可以在函数声明中的返回类型处使用`decltype`; 

```c++
int odd[] = {1, 3, 5, 7, 9};
int even[] = {0, 2, 4, 6, 8};
decltype(odd) *arrptr(int i)		// decltype(odd)的类型是int[5]类型
{
    return (i % 2) ? &odd : &even;
}
```

# 4.重载函数*

函数重载(**overloading**): 是指同一作用域内的几个函数名字相同但形参列表不同

* 重载函数一般用于这样的情况: 几种函数执行非常类似的操作但是接受不同的形参类型;
* `main`函数不能重载

当调用重载函数时, 编译器

### 定义重载函数

* 不同的形参列表: 形参数量, 形参在列表中的位置或形参类型有所不同

* 相同的名字

* 例子

  ```c++
  //Record, Account, Phone, Name都是类类型
  Record lookup(const Account&);
  Record lookup(const Phone&);
  Record lookup(const Name&);
  ```

注意:

* 返回类型的不同并不会重载函数; 假设有两个函数, 它们的形参列表一样但是返回类型不同, 则第二个函数的声明是错误的

  ```c++
  Record lookup(const Account&);
  bool lookup(const Account&);	//error
  ```

* 有些形参看起来不同, 但实际上是一样的

  ```c++
  //each pair declares the same function
  Record lookup(const Account &acct);
  Record lookup(const Account&);
  typedef Phone Telno;
  Record lookup(const Phone&);
  Record lookup(const Telno&);
  ```

### 函数重载与`const`形参

顶层`const`不影响能传入函数的类型范围; 因此顶层`const`不能使函数重载

* 假设有一个形参, 该形参拥有顶层`const`时所能接受的实参类型, 与无顶层`const`时所能接受的实参类型没有差异

底层`const`会影响能传入函数的类型范围; 因此底层`const`可以使函数重载

### 调用重载函数

当调用重载函数时, 发生函数匹配

函数匹配(**function matching**), 也称为重载确定(**overload resolution**), 是指把某次函数调用与一组重载函数中的某一个形式关联起来的过程.

* 编译器将实参列表和一组重载函数中每一个形参列表进行比较,  然后根据比较的结果确定调用重载函数中的哪个函数.

当调用重载函数时函数匹配有三种可能的结果

* 最佳匹配(**best match**): 编译器找到一个最佳匹配的函数, 然后生成调用该函数的代码
* 无匹配(**no match**): 编译器找不到任何一个函数与实参匹配, 然后发出无匹配的错误信息
* 二义性调用(**ambiguous call**): 编译器找到多个与实参匹配的函数, 但都不是最佳匹配, 然后发出错误信息

## 4.1重载和作用域*

两条性质

* 当我们在内层作用域定义一个名字时, 该名字隐藏了它在外层作用域的声明; 
  * 以上性质也适用函数名

* 在同一作用域中, 只要形参列表不同, 同一函数名可以指向多个函数实体, 这就是函数重载

由此得到

* 函数名不能跨过不同的作用域进行重载;

  ```c++
  void print(double);
  void print(const string &); //重载print函数
  void foo(int ival)
  {
      //在当前作用域中, 该函数声明隐藏了之前的print声明,只有print(int)可见
      void print(int);		
      print("Value: ");		//错误: print(const string&)被隐藏
      print(ival);			//ok: 调用print(int)
      print(3.14);			//ok: 调用print(int), 并非print(double)
  }
  ```

  * 编译器先进行名字查找, 再进行类型检查

# 5.函数相关的语言特性

## 5.1默认实参



## 5.2内联和`constexpr`函数

## 5.3调试帮助

# 6.函数匹配

## 6.1实参类型转换

# 7.函数指针