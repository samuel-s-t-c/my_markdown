# 总结

如何定义和声明函数

[toc]

# 1.函数基础*

函数(**function**)是一个有名字的代码块

## 基础

### 函数定义

函数定义

* 组成部分有: 返回类型(**return type**), 函数的名字(**name**), 由0个或多个形参(**parameter**)组成的列表以及函数体(**function body**).

  * 形参列表: 形参位于一对圆括号之内,并以逗号分隔
  * 函数体: 函数的语句块, 其中是调用函数时被执行的语句

* 形式:

  ```c++
  return_type name(parameters_list) 
  {
      /*function body*/
  }
  ```

* 例子

  ```c++
  //to determine the factorial of a given number
  int fact(int val)		
  {
      int ret = 1;
      while (val > 1)
          ret *= val--;
      return ret;
  }
  ```

### 函数调用

调用运算符`()`: 

* 作用: 通过调用运算符(**call operator**)来执行函数, 该过程称为函数调用(**function call**)

* 用法: `name(expr_list)`

  * `name`操作数可以是函数或指向函数的指针
  * `expr_list`是用逗号隔开的实参(**argument**)列表; 实参用于初始化函数的形参

* 具体动作:

  1. 使用实参列表中的实参来初始化相应的形参

  2. 将控制转换到给定的函数; 因此主调函数(**calling function**)的执行被挂起, 被调函数(**called function**)的执行开始.

* 结果: 其类型是函数的返回类型; 要么没有结果, 要么结果是函数返回的值

函数的执行过程

1. (隐式地)定义,并初始化它的形参; 这是调用表达式完成的工作
2. 执行函数体的语句, 直至遇到`return`语句;
3. 执行`return`语句; `return`语句完成的动作:
   1. 返回`return`语句中的值(如果有的话), 也就是使用该值初始化调用表达式的结果
   2. 把控制从被调函数转换到主调函数

### 形参和实参

实参(**arguments**), 是一个函数的形参(**parameters**)的初始符;

* 实参初始化对应位置的形参
  * 实参列表的第一个实参初始化形参列表的第一个形参, 第二个实参初始化第二个形参, 以此类推
  * **标准没有规定实参的求值顺序; 编译器能以任意顺序对实参求值**
* 实参的类型必须与对应位置的形参类型匹配; 即两者类型相同, 或者实参类型能够转换成形参类型
* 实参的数量必须和形参的数量一致

### 函数形参列表

* 形参列表可以为空, 但不能省略; 为了与C语言兼容, 可以使用关键字`void`表示空列表

  ```c++
  void f1() {/*...*/}
  void f2(void) {/*...*/}
  ```

* 形参列表中的形参通常用逗号隔开; 每个形参都是含有一个声明符的声明

  ```c++
  int f3(int v1, v2) {/*...*/} 		//error
  int f4(int v1, int v2) {/*...*/}	//ok
  ```

* 形参的名字是可选的; 但是无法使用未命名的形参.
* 形参的名字不能相同
* 在函数的最外层作用域中的局部变量的名字不能与形参的名字相同

### 函数返回类型

* 大多数类型都能用作函数的返回类型; 一种特殊的返回类型是`void`, 表示函数不返回任何值
* 不能用作返回类型的类型
  * 数组类型
  * 函数类型(**function type**)

## 1.1局部对象*

两个重要的概念

* 名字的作用域, 是指程序的部分文本, 名字在其中是可见的

* 对象的生命周期/寿命(**lifetime**), 是指程序执行过程中该对象存在的一段时间

在块作用域中定义的形参和变量, 被称为局部变量(**local variable**)/局部对象(**local object**); 

* 局部变量隐藏名字在外层作用域中的声明
* 局部变量的寿命取决于它如何定义的

在所有块作用域外定义的对象, 在整个程序执行过程中一直存在;

### 自动对象

自动对象(**automatic object**): 只在块执行时才存在的对象

* **普通局部变量**所对应的对象, 当函数的控制流经过变量定义时被创建, 当控制到达所在的块末尾时被销毁
* 当一个块执行结束后, 在该块中创建的自动对象的值是未定义的
* 自动对象没有初始符时, 执行默认初始化.
* 例子: 函数的形参是自动对象

### 局部静态对象

局部静态对象(**local static object**): 

* 局部静态对象在程序的执行路径**第一次**经过对象定义语句时初始化 并直到**程序终止**才被销毁
* 定义: `static`作用于基本类型, 如`static int i = 0;`
* 局部静态对象没有初始符时, 执行值初始化.

## 1.2函数声明*

* 函数的名字必须在使用之前声明; 

* 函数只能定义一次, 但可以声明多次.
* 除了一个例外情况(s15.3 p603), 我们可以声明一个还没定义的函数, 只要永远不使用该函数

函数声明, 也称为函数原型(**function prototype**)

* 返回类型, 函数名, 形参类型这三个元素描述了函数的接口

* 形式: `return_type name(paremeter_type);`

  * 声明中的形参可以省略名字,  不能省略类型

* 例子

  ```c++
  void print1(vector<int>::const_iterator beg,
            vector<int>::const_iterator end);
  void print2(vector<int>::const_iterator,
            vector<int>::const_iterator);
  ```

建议: 在头文件中进行函数声明

* 函数最好是在头文件中声明, 在源文件中定义

## 1.3分离式编译*

分离式编译(**separate compile**), 允许我们把程序分割成几个文件, 而且每个文件可以独立编译.

* 大多数编译器提供分离式编译每个源文件的机制, 这一过程通常会产生包含对象代码(**object code**)的对象文件(**object file**), 文件后缀是`.obj`(Windows)或`.o`(UNIX).
* 编译器可以把对象文件链接(**link**)在一起形成可执行文件(**executable file**)
* 要生成可执行文件(**executable file**), 必须告诉编译器所有用到的代码在哪里; 

# 2.实参传递*

每次调用函数都会创建形参, 并用传入的实参对形参初始化; 

形参初始化的过程与变量初始化一样

* 当形参是引用类型时, 形参绑定到对应的实参; 此时, 实参被引用传递(**passed by reference**), 函数被传引用调用(**called by reference**)
* 当形参是非引用类型时, 形参拷贝对应实参的值; 此时, 实参被值传递(**passed by value**), 函数被传值调用(**called by value**)

## 2.1值传递passing arguments by value*

与初始化非引用类型的变量一样, 值传递一个实参, 就是拷贝实参的值并把该值初始化相应的形参

* 这里的形参和实参是两个相互独立的对象; 因此对形参做的所有操作都不会影响实参

* 指针类型的形参
  * 对应的实参被值传递; 因为是指针类型, 该形参可以间接访问它所指的对象, 可以修改它所指对象的值(如果所指对象不是`const`)

## 2.2引用传递passing arguments by reference*

与初始化引用类于的变量一样, 引用传递一个实参, 就是把形参绑定到相应的实参对象

* 在这里, 对形参进行操作, 实际上是对形参所指的对象进行操作

引用形参的几点作用

* 使用引用形参以避免拷贝
  * 大型容器或大型类类型的对象的拷贝是比较低效的; 
  * 某些类型不支持拷贝操作
* 使用引用形参以返回额外信息
  * 一个函数只能返回一个值;
  * 如果需要返回多个值时, 其中一种方法是: 给函数传入引用实参, 用于保存额外的需要返回的值. 

## 2.3`const`形参和实参*

和变量的初始化过程一样, 关于`const`的规则有

* 可忽略实参的顶层`const`, 即实参可以是`const`, 也可以是非`const`;
  * 由于上面的性质, 形参有没有顶层`const`, 尽管形式上有差异, 但并不会让形参列表有明显的区别; 所以, 在定义重载函数时, 顶层`const`也是可忽略的

	```c++
  void fcn(const int i) {/*...*/}
  void fcn(int i) {/*...*/}		//error: 拥有相同的形参列表
  ```

* 不能忽略实参的底层`const`
* 非`const`可转换成`const`, 反之不然

指针或引用形参和`const`(p213)

* 如果可能, 使用指向`const`的指针或引用形参; 因为指向非`const`的指针或引用形参会极大地限制了函数所能接受的实参类型.
  * 指向非`const`的引用形参, 不能接受的实参有: 字面值, 表达式, 需要转换的对象, `const`对象
  * 指向非`const`的指针形参, 不能接受的实参有: 字面值, 表达式, 指向`const`的指针 

## 2.4数组形参

数组的两个特殊性质

* 不支持拷贝操作; 因此, 不能值传递数组
* 当使用数组时会将其转换成指针; 因此, 传递数组时实际上传递一个指针

把形参写成类似数组类型的形式, 实际上等于指针类型

```C++
//尽管形式不同, 但这三个函数声明是等价的, 都有一个const int*类型的形参
void print(const int*);
void print(const int[]);	// 函数的意图是作用于一个数值
void print(const int[10]);	// 这里的维度表示数值最好含有多少元素; 维度不影响类型
```

由于数组是以指针的形式传递给函数的, 函数不能从该实参中知道数组的尺寸; 函数需要调用者提供额外的信息, 有三种常用的技术

* 使用标记指明数组的长度: 
  * 在数组中包含一个表示结尾的标记, 如C风格字符串中的空字符
* 使用标准库规范:
  * 使用两个指针, 一个指向首元素, 一个指向尾后
* 使用一个表示数值大小的形参

多维数组类型的形参

* 多维数组是数组的数组, 所以其元素是数组类型
* 如上述那样, 传递数组时实际上传递一个指针; 对于多维数组, 该指针是一个指向数组的指针; 所以数组第二维(以及后面所有维度)的大小都是数组类型的一部分, 不能省略.

数组引用类型的形参: 

* 数组引用类型的形参绑定到数组类型的实参; 不是指针类型

* 因为数组的维度是类型的一部分
  * 可以从该形参中得到数组的维度
  * 但只能接受这种数组类型的实参; 维度也要一样

## 2.5`main`函数的形参: 处理命令行选项 

有时需要给`main`传递实参, 一种最常见情景是: 让用户设置一组选项来确定程序要执行的操作.

`main`函数有两个(可选的)形参:

* 第一个形参是`int`类型; 

* 第二个形参是`char **`类型; 相应的实参

  ```c++
  int main(int argc, char **argv) {...}
  int main(int argc, char *argv[]) {...}	//char *argv[] 等于 char **argv
  ```

传给`main`函数的实参: 从命令行传来的

* 第一个实参`argc`是第二个实参`argv`所表示的数组的维度

* 第二个实参 `argv`是一个数组, 其元素是指向C风格字符串的指针;

  * 第一个元素要么指向程序的名字, 要么指向一个空字符串; 
  * 后面的元素依次是命令行中提供的字符串. 
  * 尾后位置存在一个值为0的元素.

* 例子:

  ```c++
  prog -d -o ofile data0
  ```

  * 假设有一个可执行文件`prog`; 在命令行中输入以上指令

  * 此时程序中`main`函数的`argc`等于5, `argc`包含如下的C风格字符串

    ```C++
    argv[0] = "prog";  //也可能是一个空字符串
    argv[1] = "-d";
    argv[2] = "-o";
    argv[3] = "ofile";
    argv[4] = "data0";
    argv[5] = 0;
    ```

## 2.6可变形参



# 3.返回类型和`return`语句

## 3.1无返回值的函数

## 3.2有返回值的函数

## 3.3返回数组指针

# 4.重载函数

## 4.1重载和作用域

# 5.特殊用途的特性

## 5.1默认实参

## 5.2内联和`constexpr`函数

## 5.3调试工具

# 6.函数匹配

## 6.1实参类型转换

# 7.函数指针