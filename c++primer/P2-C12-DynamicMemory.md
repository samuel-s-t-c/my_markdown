# 总结

动态分配

智能指针

[toc]

# 1.动态内存与智能指针

C++允许动态分配, 在程序运行时分配对象

* 动态内存的管理是通过一对运算符`new`和`delete`来完成
  * `new`: 在动态内存(堆)中分配, 也可以初始化, 对象; 返回一个指向该对象的指针
  * `delete`: 接受一个指向动态对象的指针, 然后销毁该对象, 释放对应的内存
* 正确地管理动态内存是非常棘手的; 特别是, 在稍微复杂的系统中就很难保证在正确时间释放内存

对象都有寿命(**lifetime**)

* 一些对象的寿命与在哪里创建有关, 有严格定义的寿命, 由编译器自动创建和销毁
  * 全局对象在程序启动时分配, 在程序结束时销毁; 
  * 局部自动对象在进入其定义所在的块时创建, 在离开块时销毁
  * 局部静态对象在第一次使用前分配, 在程序结束时销毁

* 动态分配(**dynamically allocated**)的对象的寿命与在哪里创建无, 只有显式释放才会销毁; 由程序来控制它的创建和销毁


内存按保存的对象分类

* 静态内存(**static memory**): 用来保存局部静态对象, 类的静态成员以及定义在任何函数之外的变量

* 栈内存(**stack memory**): 用来保存定义在函数内的非静态对象
* 堆内存(**heap memory**)/自由空间(**free store**): 用来保存动态分配的对象

C++11标准库提供了两种智能指针(**smart pointer**)模板类来管理动态对象, 定义在`memory`头文件中

* 智能指针的行为与常规指针类似, 重要的区别是智能指针可以自动释放所指向的对象

* `shared_ptr`类型: 允许多个指针指向同一对象
* `unique_ptr`类型: 独占所指向的对象
* 标准库还定义一个伴随类`weak_ptr`:  一种弱引用, 指向`shared_ptr`所管理的对象

## 1.1`shared_ptr`类(C++11)*

`shared_ptr`与`unique_ptr`的共有操作; 

| 操作                                 | 描述                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| `shared_ptr<T> sp;`, `unique<T> up;` | 指向`T`类型对象的空智能指针                                  |
| `p`转换成`bool`                      | 如果`p`指向一个对象, 转换为`true`, 否则为`false`             |
| `*p`                                 | 解引用; 返回`p`所指的对象                                    |
| `p->mem`                             | 等于`(*p).mem`                                               |
| `p.get()`                            | 返回在`p`中保存的指针;若`p`释放其对象,返回指针所指对象也消失 |
| `swap(p, q)`, `p.swap(q)`            | 交换`p`和`q`中的指针                                         |

`shared_ptr`专用的操作

| 操作                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `make_shared<T>(args)` | 返回一个`shared_prt`; 所指的对象是类型`T`, 使用`args`初始化  |
| `shared_ptr<T> p(q)`   | `p`是`shared_ptr`对象`q`的拷贝, 递增`q`中的引用计数; `q`中的指针必须能转换成`T*` |
| `p = q`                | `p`和`q`是`shared_ptr`对象, 所保存的指针必须能相互转换; 递增`q`的引用计数, 递减`p`的引用计数 |
| `p.unique()`           | 返回`true`, 如果`p.use_count()`为1; 其他情况, 返回`false`    |
| `p.use_count()`        | 返回与`p`共享对象的智能指针数量. 可能很慢, 主要用于调试.     |

具体说明

`make_shared<T>(args)`: 最安全的分配和使用动态内存的方式; 模板函数

* 该函数分配和初始化对象于动态内存, 返回一个指向该对象的`shared_ptr`
  * 该对象的类型是`T`, 根据`args`进行初始化

### 引用计数

每个`shared_ptr`都会记录其所管理的对象被多少个`shared_ptr`指向着; 通常将这个`shared_ptr`的数量称为引用计数(**reference count**).

* 拷贝一个`shared_ptr`, 其引用计数递增; 属于这种情况有: 
  * 函数的值传递和值返回
  * 作为赋值的右操作数
  * 拷贝初始化
* 销毁一个`shared_ptr`, 其引用计数递减; 属于这种情况有:
  * 作为赋值的左操作数; 是指原来的(赋值前的)`shared_ptr`的计数递减
  * 局部对象离去其作用域

当一个`shared_ptr`的引用计数变为0, 该`shared_ptr`自动销毁所指向的对象和释放该对象使用的内存

* 这是通过析构函数(**destructor**)完成销毁工作的; 析构函数控制此类型的对象销毁时的行为
* 在`shared_ptr`的析构函数中递减引用计数; 如果计数为0, 销毁所指向的对象和释放该对象使用的内存

注意: 

* 引用计数并不一定是一个计数器; 如何实现引用计数是由标准库的具体实现来决定

### 类与动态寿命的资源

> 动态寿命(**dynamic lifetime**), 是指动态分配的资源的寿命

程序使用动态内存的原因

* 不知道需要使用多少个对象; 例子: 容器类
* 不知道所需对象的准确类型;
* 需要在多个对象间共享数据

### 例子:`StrBlob`类(p455)

## 1.2直接管理动态内存



## 1.3`shared_ptr`和`new`

## 1.4智能指针和异常

## 1.5`unique_ptr`类

## 1.6`weak_ptr`类

# 2.动态数组

## 2.1数组与`new`

## 2.2`allocator`类

# 3.例子: 文本查询程序

