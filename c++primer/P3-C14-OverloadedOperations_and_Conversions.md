# 总结

类类型的运算符和类型转换

[toc]

# 1.基本概念*

> 通过运算符重载, 可以自定义类类型的运算符的含义; 恰当地使用运算符重载能令程序更易于编写和阅读

类的重载运算符是具有特殊名字的函数

* 形式
  * 其名字由关键字`operator`和要定义的运算符符号组成
  * 与其他函数一样, 重载运算符包含返回类型, 形参列表和函数体
  * 重载运算符函数的形参数量, 就是该运算符作用的运算对象的数量
    * 一元运算符有一个形参; 二元运算符有两个形参, 且左操作数传递给第一个形参, 右操作数传递给第二个形参
    * 如果重载运算符函数是某个类的成员函数, 运算符的第一个操作数是隐式地与`this`指针绑定的; 此时, 如果有其他操作数, 这些操作数作为形参列表中的形参

* 限制

  * 除了函数调用运算符`operator()`, 其他重载运算符不能含义默认实参

  * 运算符函数必须要么是类的成员, 要么至少含义一个类类型的形参; 

    * 也就是说, 不能改变运算符作用于内置类型对象时的含义

  * 只能重载已有的运算符, 不能创建新的运算符符号

  * 可以重载大多数运算符, 有些不能重载;

    ![image-20200405185204203](assets/image-20200405185204203.png)

    * `+, -, *, &`这四个符号既是一元运算符也是二元运算符; 能够根据形参的数量来推断要定义的运算符

* 调用重载运算符
  * 像内置运算符一样调用重载运算符, 如`obj1 + obj2`
  * 像成员函数一样调用重载运算符函数, 如`obj1.operator+=(obj2)`
  * 像普通函数一样调用重载运算符函数, 如`operator+(obj1, obj2)`

* 重载运算符的性质

  * 重载运算符的优先度和结合律与对应的内置运算符一样
  * 使用重载运算符本质是一次函数调用, 因此关于运算对象求值顺序的规则对重载运算符没有保留下来
    * 因此, 不建议重载保证求值顺序的运算符, 如`&&`, `||`, `,`等

* 建议

  * 对于`&&`和`,`运算符, C++为其定义了用于类类型对象时的特殊含义, 所以一般来说不应该重载它们

  * 重载运算符的含义最好与内置类型一致
    * 如果类执行IO操作, 则定义位移操作运算符`<<`和/或`>>`使其与内置类型的IO保持一致
    * 如果类的某个操作是检查相等性, 则定义相等性运算符`==`和/或`!=`
    * 如果类包含一个简单的自然的排序操作, 则定义`operator<`, 甚至定义所有关系运算符
    * 重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容: 逻辑和关系运算符应该返回`bool`, 算术运算符应该返回一个类类型的值, 赋值运算符和复合赋值运算符应该返回左操作数的引用

## 赋值和复合赋值运算符

建议

* 赋值之后, 左操作数和右操作数应该有相同的值; 运算符返回左操作数的引用
* 如果类含义算术运算符或位运算符, 则最好也提供对应的复合赋值运算符; 复合赋值运算符的行为也应该与其内置版本一致, 如`+=`的行为应该是先执行`+`再执行`=`

## 选择作为成员或非成员

当定义重载运算符时, 我们必须决定是将其声明位为类的成员函数还是声明为一个非成员函数. 不过, 有些运算符必须是成员函数;

下面是几条原则

* `=`赋值, `[]`下标, `()`调用, `->`成员访问箭头等运算符必须是成员函数
* 复合赋值运算符通常应该是成员
* 改变对象状态或者与给定类型密切相关的运算符通常应该是成员, 如递增, 递减, 解引用等等
* 具有对称性的运算符通常应该是非成员函数, 如算术, 相等性, 关系, 位运算等等

作为成员和非成员的区别

* 作为成员函数的运算符, 它的第一个操作数必须是其所属类的一个对象
* 作为非成员函数的运算符, 至少有一个操作数是类类型即可

# 2.输入和输出运算符*

IO标准库分别使用`>>`和`<<`运算符执行输入操作和输出操作; 支持IO的类通常定义这些运算符的版本

## 2.1重载输出运算符`<<`*

输出运算符的重载版本通常是: `ostream &operator<<(ostream &, const T&);`

* 为了与`iostream`标准库兼容, 类的输出运算符应该是非成员函数; 此时若想要输出类的非公有成员, 需要将输出运算符声明为友元
* 第一个形参通常是非`const`的`ostream`对象引用
  * 因为写入输出流会改变它的状态, 所以`ostream`对象是非`const`的
  * 因为不能拷贝`ostream`对象, 所以该形参是引用类型

* 第二形参通常是想要输出的类类型对象的`const`引用
  * 该形参为引用类型的原因是希望避免拷贝实参
  * 该形参为`const`的原因是一般情况下输出操作不会改变对象的内容

* `operator<<`通常要返回它的`ostream`形参
  * 原因是为了与其他输出运算符保持一致

建议: 

* 输出运算符尽量减少格式化操作; 让用户去控制输出的细节

## 2.2重载输入运算符`>>`*

输入运算符的重载版本通常是: `istream &operator>>(istream &, T&);`

* 为了与`iostream`标准库兼容, 类的输入运算符应该是非成员函数; 
* 第一个形参通常是非`const`的`istream`对象引用
  * 因为读取输入流会改变它的状态, 所以`istream`对象是非`const`的
  * 因为不能拷贝`istream`对象, 所以该形参是引用类型

* 第二形参通常是接受数据的类类型对象的非`const`引用
  * 该形参为引用类型的原因是希望避免拷贝实参
  * 该形参为非`const`的原因是一般情况下输入操作会改变对象的内容

* `operator>>`通常要返回它的`istream`形参
  * 原因是为了与其他输入运算符保持一致

建议

* 输入运算符必须处理输入可能失败的情况; 
  * 如果出现错误, 应该确保接受数据的对象处于有效的状态
  * 可能发生的错误: 输入流包含了错误类型的数据, 或读取操作遇到了文件末尾, 或遇到输入流的其他错误
* 一些输入运算符需要做额外的工作, 如检验数据是否符合设计者的要求等等; 如果输入不符合要求, 应该设置输入流的条件状态来表示失败的输入, 通常只设置`failbit`.

# 3.算术和关系运算符

通常, 算术和关系运算符被定义为非成员函数, 以允许对左右操作数进行类型转换; 因为这些运算符一般不需要改变运算对象的状态, 所以形参通常是`const`引用.

## 3.1相等性运算符

## 3.2关系运算符

# 4.赋值运算符

# 5.下标运算符

# 6.递增和递减运算符

# 7.成员访问运算符

# 8.函数调用运算符

## 8.1Lambda是函数对象

## 8.2标准库定义的函数对象

## 8.3可调用对象和`function`

# 9.重载, 类型转换和运算符

## 9.1类型转换运算符

## 9.2避免二义性类型转换

## 9.3函数匹配与重载运算符