# 总结

表达式是由一个或多个运算符组成的.([汇总](#12.汇总))

* 各种运算符的用法, 优先级, 结合律, 求值顺序
* 操作数的类型转换

---

[toc]

# 1.表达式基础

表达式由可选的运算符和一个或多个运算数（**operands**)组成; 对表达式求值时得到一个结果.

* 字面值和变量就是最简单的表达式, 其结果是它们自己的值. (没有运算符, 只有一个运算数)

## 1.1基本概念*

* 运算符按操作数的多少可分为:
  *  一元运算符(**unary operator**)
  * 二元运算符(**binary operator**)
  * 三元运算符(**ternary operator**)

* 运算符和操作数的组合
  * 对于含有多个运算符的复杂表达式来说, 要想求值需要解决这个关键问题: 运算顺序. 所以有关于运算符的一些规则
    * 运算符的优先级(**precedence**), 结合律(**associativity**)
    * 操作数的求值顺序(**order of evaluation**)

* 操作数的转换
  * 表达式求值时, 经常需要把操作数从一种类型转换另一种类型. 
* 重载运算符(**overloaded operator**)
  * C++定义了运算符作用于内置类型和复合类型的对象时所执行的操作/含义.
  * 运算符作用于类类型的对象时, 用户可以自行定义其含义; 因为运算符被赋予更多的意义, 所以被称为**重载运算符**.
  * 注意: 不能改变运算符的优先级和结合律, 还有操作数的数量.

* 左值(**Lvalue**)和右值(**Rvalue**)
  * 对象可以分为左值和右值.
    * 在C中, 左值是能够放在赋值语句左侧的值, 右值是不能放在赋值语句左侧的值.
    * 在C++中, 二者的区别就没那么简单了. 粗略地讲, 当一个对象被用作右值时, 用的是对象的值(它的内容); 当对象被用作左值时, 用的是对象的identity(它在内存中的位置).
  * 在运算符需要右值的地方可以使用左值, 反之不然.
  * 使用`decltype`时, 左值和右值有所不同; 左值: 相应的引用类型; 右值: 相应的类型

## 1.2优先级和结合律

复合表达式(**compound expression**)是指含有两个或以上运算符的表达式.

在复合表达式的求值过程中首先需要将运算符和操作数组合在一起. 而优先级(**precedence**)和结合律(**associativity**)决定了操作数组合的方式. 

* 优先级: 运算符的优先级越高, 运算符越先与操作数结合 
  * 优先级只是规定了运算符与对象的组合顺序, 并没有说明操作数按照什么顺序求值.
* 结合律: 在优先级相同时, 结合律决定运算符的结合顺序(从左向右, 或从右向左)
* 小括号可以无视上述的组合规则; 表达式中被括起来的部分被当成一个单元来求值, 然后再与其他部分一起按照默认组合规则来组合.
* 例子: ` 6+3*4/2-2` : `*`和`/`运算符的优先级比`+`,`-`的高; 而`*`和`/`有相同的优先级, 根据它们的结合律(左结合律), 应该从左向右结合. 因此式子等于`((6+((3*4)/2))-2)`

### 1.3求值顺序

大多数的运算符并没有规定求值顺序; 不能假设求值顺序, 因为求值顺序是未定义的.

* 对于没规定求值顺序的运算符, 如果表达式指向并修改同一个对象, 将引发错误并产生未定义的行为. 例子, `<<`运算符没有规定求值顺序

* ```c++
  int i = 0;
  cout << i << " " << ++i << endl;	// undefined
  ```

优先级规定了操作数的组合方式, 但是没有说明操作数按照什么顺序求值. 也就是说, 求值顺序是与优先级, 结合律无关.

* 例如: `int i = f1() * f2();`, 可以知道`()`函数调用运算符的优先级更高, 所以`f1()`和`f2()`是在执行乘法之前执行的. 但是, 我们无法知道`f1`和`f2`函数哪个先调用.
* `f() + g() * h() +j()`; 
  * 优先级规定了`g()`的返回值和`h()`的返回值相乘
  * 结合律规定了`f()`和`g()*h()`的乘积相加, 所得结果再与`j()`的返回值相加
  * `+`, `*`都没有规定求值顺序, 所以这四个函数的调用顺序是未定义的. 
  * 如果这些函数是不相干的函数, 即不会影响到同一个对象的状态, 那么该表达式是不受求值顺序影响的; 如果其中有函数影响到同一对象, 这是一条错误的表达式.

明确规定求值顺序的4种运算符

* 逻辑与运算符`&&`: 保证先求左操作数的值; 而且只有左操作数的值为`true`时才继续求右操作数的值
* 逻辑或运算符`||`: 保证先求左操作数的值; 而且只有左操作数的值为`false`时才继续求右操作数的值
* 条件运算符`?:`: 保证先求第一操作数的值; 根据第一操作数的值来决定下一个被求值的操作数
* 逗号运算符`,`: 保证先求左操作数的值, 再求右操作数的值

# 2.算术运算符Arithmetic Operators

**算术运算符:** 

* 表格以优先级分组, 从高到低排序; 都是左结合律

| 运算符 |   功能   |     用法      | 说明                                         |
| :----: | :------: | :-----------: | -------------------------------------------- |
|  `+`   | 一元正号 |   `+ expr`    | 返回操作数的值的一个(可能被提升的)副本       |
|  `-`   | 一元负号 |   `- expr`    | 对操作数的值取负后, 返回其(可能被提升的)副本 |
|        |          |               |                                              |
|  `*`   |   乘法   | `expr * expr` |                                              |
|  `/`   |   除法   | `expr / expr` | 若操作数是整型, 返回值也是整型               |
|  `%`   |   求余   | `expr % expr` | 只用于整数类型                               |
|        |          |               |                                              |
|  `+`   |   加法   | `expr + expr` |                                              |
|  `-`   |   减法   | `expr - expr` |                                              |

* 操作数可以是任意算术类型以及任意能转换为算术类型的类型. 
  * 其中, 一元正号, 加法和减法运算符都能作用于指针;
* 操作数和求值结果都是右值
* 小整数类型的操作数会被提升成更大的整数类型; 所有操作数最终会转换成同一类型.

**具体说明:**

`/`除法运算符

* 整数间的除法返回一个整数; 商的小数部分直接弃除.
  * C++早期版本允许结果为负值的商向上或向下取整; C++11标准规定商一律向0取整(即直接切除小数部分)
* 操作数的符号相同, 且商不为0时, 商为正, 否则为负.

`%`求余运算符: C++中求余运算符也称为取模运算符

* 操作数必须是整数类型
* C++定义的取模操作是指, 如果`m`和`n`都是整数, `n`不为零, 那么`(m / n) * n + m % n`等于`m`;
  * 由定义可得, 若`m % n`不为0时, 它的符号和`m`相同.
    * 如果`-m`不会导致溢出, 则有`m % (-n)`等于`m % n`, `(-m) % n`等于`-(m % n)`
  * 现在禁止的规则: C++早期版本允许`m % n`匹配`n`的符号, 如果该实现的`m / n`的负值商向负无穷取整

**注意:**

* `bool`类型的值最好不要参与运算; 如: 对`true`取负, 结果仍然为`true`.

  * ```c++
    bool b = true;
    bool b2 = -b;	// b2 is true!
    ```

  * 解释: 在求值时, `bool`类型的操作数将被提升为`int`类型, `bool`值`true`被提升为`int`值`1`, `bool`值`false`被提升为`int`值`0`. 

  * 例子中,  `-b`表达式中 `b`的值变成`1`, 然后对`1`取负得到`-1`, 所以`-b`的返回值是`-1`, 也就是`b2`的初始符. 在布尔类型初始化时, 非零初始符将转换成布尔值`true`

* 注意表达式是否溢出(**overflow**)

# 3.逻辑和关系运算符Logical and Relational Operators

**逻辑和关系运算符:**

* 表格以优先级分组, 从高到低排序; 

| 结合律 | 运算符 | 功能       | 使用           | 说明             |
| ------ | ------ | ---------- | -------------- | ---------------- |
| Right  | `!`    | 逻辑非     | `!expr`        | 对操作数的值取反 |
|        |        |            |                |                  |
| Left   | `<`    | 小于       | `expr < expr`  |                  |
| Left   | `<=`   | 小于或等于 | `expr <= expr` |                  |
| Left   | `>`    | 大于       | `expr > expr`  |                  |
| Left   | `>=`   | 大于或等于 | `expr >= expr` |                  |
|        |        |            |                |                  |
| Left   | `==`   | 相等       | `expr == expr` |                  |
| Left   | `!=`   | 不相等     | `expr != expr` |                  |
|        |        |            |                |                  |
| Left   | `&&`   | 逻辑与     | `expr && expr` |                  |
|        |        |            |                |                  |
| Left   | `||`   | 逻辑或     | `expr || expr` |                  |

* 关系运算符
  * 其操作数是算术或指针类型的右值
  * 其结果是布尔类型的右值
* 逻辑运算符
  * 其操作数是任意可转换成布尔类型的右值
  * 其结果是布尔类型的右值

**具体说明:**

* `&&`逻辑与运算符, `||`逻辑或运算符
  * `&&`逻辑与运算符: 当且仅当两个操作数都为`true`时结果为`true`
  * `||`逻辑或运算符: 只要有一个操作数为`true`, 其结果为`true`
  * 求值顺序: 先计算左操作数的值, 然后根据左操作数的结果无法确定表达式的结果时, 才会计算右操作数的值.  这种策略称为短路求值(**short-circuit evaluation**).
    * `&&`逻辑与运算符:  当左操作数为`true`时才对右操作数求值
    * `||`逻辑或运算符: 当左操作数为`false`时才对右操作数求值

# 4.赋值运算符Assignment Operators

`=`赋值运算符: 

* 其左操作数必须是可修改的左值
* 其右操作数是右值.
  * 如果左右操作数的类型不相同, 右操作数被转换成左操作数的类型; 如果不允许这种类型转换, 则表达式报错.
  * 在C++11标准下, 右操作数可以是花括号括起的初始符列表; 
    * 初始符列表可为空, 那么编译器会生成已值初始化的临时对象, 并将临时对象赋给左操作数.
    * 若左操作数是内置类型, 初始符列表最大只能包含一个值, 且该值不需要进行收缩转换(**narrowing conversion**)
    * 若左操作数是类类型, 赋值运算取决于类本身.
* 结果是左操作数, 并且是一个左值; 结果的类型是左操作数的类型.
* 赋值运算是右结合的
  * 在多重赋值语句中, 每对相邻的对象需要满足以下条件之一
    * 两对象是相同类型的
    * 右侧对象的类型可以转换为左侧对象的类型.

复合赋值运算符: 

* 都为左结合

* 算术复合赋值运算符: `+=`, `-=`, `*=`, `/=`, `%=`
* 位复合赋值运算符: `<<=`, `>>=`, `&=`, `^=`, `|=`
* `a op= b` 基本等于`a = a op b` ; 不同的是, 复合赋值中左操作数只被求值一次, 而普通的赋值中左操作数被求值两次.

注意:

* 切勿混淆赋值运算符`=`和相等运算符`==`

# 5.递增和递减运算符Increment and Decrement Operators

`++`递增运算符和`--`递减运算符

* 前置版本`++obj`, `--obj`: 
  * 右结合
  * 接受一个左值, 递增(递减)运算对象; 结果是**改变后**的对象, 是一个左值
* 后置版本`obj++`, `obj--`: 
  * 左结合
  * 接受一个左值, 递增(递减)运算对象; 结果是**改变前**的对象的副本, 是一个右值

# 6.成员访问运算符The Member Access Operators

两种提供成员访问的运算符: `.`点运算符和`->`箭头运算符

`.`点运算符

* 作用: 从一个类对象中获取一个成员
* 结合律: 左结合

* 用法:`obj.mem`
* 结果: 类对象的成员的引用, 是一个左值

`->`箭头运算符

* 作用: 从一个指向类对象的指针中获得一个成员,等价于`(*ptr).mem`
* 结合律: 左结合

* 用法:`ptr->mem`
* 结果: 类对象的成员的引用, 是一个左值

# 7.条件运算符The Conditional Operator

`?:`条件运算符:

* 作用: 允许把简单的if-else逻辑嵌入到单个表达式中
* 结合律: 右结合
* 用法:`cond ? expr1 : expr2`
  * 先对`cond`求值; 当`cond`为`true`时, 对`expr1`求值, 否则对`expr2`求值
  * `expr1`和`expr2`表达式要么拥有相同的类型, 要么能转换为某个共同的类型
* 结果
  * 结果是左值的情况
    * `expr1`和`expr2`是左值时
    * `expr1`和`expr2`能够转换为某个共同的左值类型
  * 在其他情况下, 结果是右值

**注意:**

* 嵌套条件运算符: 条件表达式可以作为另外一个条件运算符的`cond`或`expr`.
* 

# 8.位运算符Bitwise Operators

**位运算符**

* 表格以优先级分组, 从高到低排序; 

| 运算符 | 功能   | 用法             |
| ------ | ------ | ---------------- |
| `~`    | 位求反 | `~expr`          |
|        |        |                  |
| `<<`   | 左移   | `expr1 << expr2` |
| `>>`   | 右移   | `expr1 >> expr2` |
|        |        |                  |
| `&`    | 位与   | `expr & expr`    |
|        |        |                  |
| `^`    | 位异或 | `expr ^ expr`    |
|        |        |                  |
| `|`    | 位或   | `expr | expr`    |

* 位运算符把运算对象看成二进制的集合; 位运算符提供检查和设置二进制位的功能. 
  * 标准库类型`bitset`是用于表示任意大小的二进制位集合, 定义了位运算符.
* 位运算符的操作数类型是整数类型

**具体说明:**

**移位运算符**(**Bitwise Shift Operators**): `<<`左移运算符和`>>`右移运算符

* 作用: 把左操作数按照右操作数的要求移动指定位数
* 结合律: 左结合
* 用法: `integer << unsigned_integer`, `integer >> unsigned_integer`
* 结果: 经过移动后的(可能被提升的)左操作数的拷贝, 是一个右值
* 要求: 右操作数一定不能为负, 而且值比兴严格小于结果的位数, 否则会产生未定义的行为
* 具体细节:
  * 被移出边界之外的位都被舍弃掉
  *  `<<`运算符在右侧插入值为0的二进制位; 
  * `>>`运算符的行为取决于左操作数的类型
    * 无符号类型: 在左侧插入值为0的二进制位; 
    * 带符号类型: 在左侧插入值为0的二进制位, 或插入符号位的值; 由实现来选择哪种结果

**位求反运算符**: `~`运算符

* 作用: 将操作数逐位取反, 则将1置为0, 将0置为1
* 结合律:左结合
* 用法: `~expr`
* 结果: 求反后的一个新的右值

**位与, 或, 异或运算符**: `&`运算符, `|`运算符, `^`运算符

* 作用: 在两个操作数上逐位执行相应的逻辑操作
* 结合律: 左结合
* 用法: `expr & expr`, `expr | expr`, `expr ^ expr`
* 结果: 逻辑操作后的一个新的右值
* 具体细节
  * `&`运算符: 两个操作数的对应位置都是1, 则运算结果中该位置为1, 否则为0
  * `|`运算符: 两个操作数的对应位置都是0, 则运算结果中该位置为0, 否则为1
  * `^`运算符: 两个操作数的对应位置有且只有一个为1, 则运算结果中该位置为1, 否则为0

**注意:**

* 标准没有规定位运算符如何处理符号位, 因此最好仅将位运算符用于处理无符号类型
  * 如果运算对象是带符号的, 其值为负, 那么位运算符如何处理该运算对象是机器相关的; 此时的左移操作可能会改变符号位的值, 这是一种未定义的行为.

  

# 9.sizeof运算符

# 10.逗号运算符Comma Operator

# 11.类型转换

# 12.汇总

## 运算符的含义, 优先级和结合律

| 结合律 |      运算符      | 功能                       | 结果 | 用法                    |
| ------ | :--------------: | :------------------------- | :--: | ----------------------- |
| L      |       `::`       | 全局作用域                 |      | `::name`                |
| L      |       `::`       | 类作用域                   |      | `class::name`           |
| L      |       `::`       | 命名空间作用域             |      | `namespace::name`       |
|        |                  |                            |      |                         |
| L      |       `.`        | 成员选择                   |  L   | `obejct.member`         |
| L      |       `->`       | 成员选择                   |  L   | `pointer->member`       |
| L      |       `[]`       | 下标                       |      | `expr[expr]`            |
| L      |       `()`       | 函数调用                   |      | `name(expr_list)`       |
| L      |       `()`       | 类型转换                   |      | `type(expr_list)`       |
|        |                  |                            |      |                         |
| R      |       `++`       | 后置递增运算               |  R   | `lvalue++`              |
| R      |       `--`       | 后置递减运算               |  R   | `lvalue--`              |
| R      |     `typeid`     | 类型ID                     |      | `typeid(type)`          |
| R      |     `typeid`     | 运行时类型ID               |      | `typeid(expr)`          |
| R      |     显式转换     | 类型转换                   |      | `cast_name<type>(expr)` |
|        |                  |                            |      |                         |
| R      |       `++`       | 前置递增运算               |  L   | `++lvalue`              |
| R      |       `--`       | 前置递减运算               |  L   | `--lvalue`              |
| R      |       `~`        | 位求反                     |  R   | `~expr`                 |
| R      |       `!`        | 逻辑非                     |  R   | `!expr`                 |
| R      |       `-`        | 一元负号                   |  R   | `-expr`                 |
| R      |       `+`        | 一元正号                   |  R   | `+expr`                 |
| R      |       `*`        | 解引用                     |      | `*expr`                 |
| R      |       `&`        | 取地址                     |  R   | `&lavlue`               |
| R      |       `()`       | 类型转换                   |      | `(type)expr`            |
| R      |     `sizeof`     | 对象的大小                 |      | `sizeof(expr)`          |
| R      |     `sizeof`     | 类型的大小                 |      | `sizeof(type)`          |
| R      |   `sizeof...`    | 参数包的大小               |      | `sizeof...(name)`       |
| R      |      `new`       | allocate object/分配对象   |      | `new type`              |
| R      |     `new[]`      | allocate array/分配数组    |      | `new type[size]`        |
| R      |     `delete`     | deallocate object/释放对象 |      | `delete expr`           |
| R      |    `delete[]`    | 释放数组                   |      | `delete[] expr`         |
| R      |    `noexcept`    | 允许抛出异常               |      | `noexcept(expr)`        |
|        |                  |                            |      |                         |
| L      |      `->*`       | 指向成员选择的指针         |      | `ptr->*ptr_to_member`   |
| L      |       `.*`       | 指向成员选择的指针         |      | `obj.*ptr_to_member`    |
|        |                  |                            |      |                         |
| L      |       `*`        | 乘法                       |  R   | `expr*expr`             |
| L      |       `/`        | 除法                       |  R   | `expr/expr`             |
| L      |       `%`        | 取模(取余)                 |  R   | `expr%expr`             |
|        |                  |                            |      |                         |
| L      |       `+`        | 加法                       |  R   | `expr+expr`             |
| L      |       `-`        | 减法                       |  R   | `expr-expr`             |
|        |                  |                            |      |                         |
| L      |       `<<`       | 位左移                     |  R   | `expr<<expr`            |
| L      |       `>>`       | 位右移                     |  R   | `expr>>expr`            |
|        |                  |                            |      |                         |
| L      |       `<`        | 小于                       |  R   | `expr<expr`             |
| L      |       `<=`       | 小于或等于                 |  R   | `expr<=expr`            |
| L      |       `>`        | 大于                       |  R   | `expr>expr`             |
| L      |       `>=`       | 大于或等于                 |  R   | `expr>=expr`            |
|        |                  |                            |      |                         |
| L      |       `==`       | 相等性                     |  R   | `expr==expr`            |
| L      |       `!=`       | 不等性                     |  R   | `expr!=expr`            |
|        |                  |                            |      |                         |
| L      |       `&`        | 位与                       |  R   | `expr&expr`             |
|        |                  |                            |      |                         |
| L      |       `^`        | 位异或                     |  R   | `expr^expr`             |
|        |                  |                            |      |                         |
| L      |       `|`        | 位或                       |  R   | `expr|expr`             |
|        |                  |                            |      |                         |
| L      |       `&&`       | 逻辑与                     |      | `expr&&expr`            |
|        |                  |                            |      |                         |
| L      |       `||`       | 逻辑或                     |      | `expr||expr`            |
|        |                  |                            |      |                         |
| R      |       `?:`       | 条件                       |  ?   | `expr?expr:expr`        |
|        |                  |                            |      |                         |
| R      |       `=`        | 赋值                       |  L   | `lvalue=expr`           |
| R      | `*=`, `\=`, `%=` | 复合赋值                   |  L   | `lvalue+=expr`等        |
| R      |    `+=`, `-=`    | 同上                       |  L   |                         |
| R      |  `<<=`, `>>=`,   | 同上                       |  L   |                         |
| R      |  `&=`,`=`, `^=`  | 同上                       |  L   |                         |
|        |                  |                            |      |                         |
| R      |     `throw`      | 抛出异常                   |      | `throw expr`            |
|        |                  |                            |      |                         |
| L      |       `,`        | 逗号                       |      | `expr, expr`            |

表格说明

* 以优先级分组, 从高到低排序
* 结合律以`L`和`R`表示左右结合律
* 结果以`L`和`R`表示左值和右值; `?`表示视情况而定的

## 求值顺序

明确规定求值顺序的4种运算符

* 逻辑与运算符`&&`: 保证先求左操作数的值; 而且只有左操作数的值为`true`时才继续求右操作数的值
* 逻辑或运算符`||`: 保证先求左操作数的值; 而且只有左操作数的值为`false`时才继续求右操作数的值
* 条件运算符`?:`: 保证先求第一操作数的值; 根据第一操作数的值来决定下一个被求值的操作数
* 逗号运算符`,`: 保证先求左操作数的值, 再求右操作数的值