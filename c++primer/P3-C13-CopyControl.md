# 总结

* 拷贝控制: 拷贝, 赋值, 移动, 销毁
  * 拷贝构造函数, 拷贝赋值运算符
  * 移动构造函数, 移动赋值运算符
  * 析构函数
* 拷贝控制与资源管理

* 交换操作



[toc]

# 前言

拷贝控制(**copy control**), 是指以下的操作

* 拷贝构造函数
* 拷贝赋值运算符
* 移动构造函数
* 移动赋值运算符
* 析构函数

如果一个类没有定义所有的拷贝控制成员, 则编译器自动定义缺失的操作

* 对于一些类来说, 不能依赖于这些操作的默认定义; 特别是需要自身管理动态内存的类

# 1.拷贝, 赋值和销毁

以最基本的操作作为开始

* 拷贝构造函数
* 拷贝赋值运算符
* 析构函数

## 1.1拷贝构造函数*

拷贝构造函数(**the copy constructor**), 是这样的构造函数, 它的第一个形参是自身类类型的引用, 其他形参都有默认值

* 第一个形参必须是引用类型; 通常是`const`引用

### 合成拷贝构造函数

如果在类没有定义一个拷贝构造函数, 编译器会替我们合成一个拷贝构造函数; 这个构造函数就是合成拷贝构造函数(**the synthesized copy constructor**)

* 注意:  只要是没有定义拷贝构造函数, 编译器就会定义一个合成拷贝构造函数; 即使定义了其他的构造函数, 也是一样
* 行为
  * 对于某些类, 合成拷贝构造函数用来阻止拷贝该类的对象;
  * 一般情况下, 合成拷贝构造函数将实参的成员逐个拷贝到正在创建的对象中; 成员的类型决定了如何复制该成员
    * 类类型的成员使用其拷贝构造函数
    * 内置类型的成员直接拷贝; 对于数组类型的成员, 合成拷贝构造函数会逐一拷贝数组成员中的元素 

### 拷贝初始化与直接初始化

区别

* 当我们使用直接初始化时, 我们要求编译器通过函数匹配来选择最佳匹配的构造函数

* 当我们使用拷贝初始化时, 我们要求编译器将右操作数拷贝到正在创建的对象中, 必要时进行类型转换, 即将右操作数转换为该类的类型

拷贝初始化通常使用拷贝构造函数来完成

* 如果该类有移动构造函数, 则拷贝初始化根据情况选择拷贝构造函数或移动构造函数.

发生拷贝初始化的情况

* 定义变量时使用`=`
* 将一个对象作为实参传递给一个非引用类型的形参
* 从一个返回类型为非引用类型的函数中返回一个对象
* 用花括号列表初始化一个数组中的元素或一个聚合类对象的成员

为什么拷贝构造函数的第一个形参必须是引用类型

* 如果该形参不是引用类型, 则初始化该形参时会使用拷贝初始化,  而拷贝初始化又会调用该拷贝构造函数本身, 如此无限循环, 永远也不会成功执行拷贝构造函数;
* 所以拷贝构造函数的第一个形参必须是引用类型

### 编译器可以绕过拷贝构造函数

在拷贝初始化过程中, 编译器可以优化代码, 跳过拷贝/移动构造函数, 直接创建对象

例如:

```c++
string null_book = "9-999-99999-9";	//拷贝初始化
```

* 例子中, 编译器可以不跳过拷贝/移动构造函数; 即使用临时量`"9-999-99999-9"`创建一个临时的`string`, 然后使用拷贝/移动构造函数将临时的`string`拷贝/移动到正在创建的`null_book`中

* 编译器也可以选择跳过拷贝/移动构造函数, 直接创建对象; 将上面的代码改写为

```c++
string null_book("9-999-99999-9");
```

## 1.2拷贝赋值运算符*

> 与类控制其对象如何初始化一样, 类也可以控制其对象如何赋值

### 重载运算符的简介

> 简要介绍一些重载运算符(**overloaded operator**), 更多见第14章

重载运算符本质上是一个函数, 其名字由`operator`后接表示要定义的运算符符号组成

* 如, 赋值运算符是一个名为`operator=`的函数

与其他普通函数一样, 运算符函数有返回类型和形参列表

* 形参表示运算符的操作数

一些运算符必须被定义为成员函数, 如赋值运算符; 

* 作为成员函数的运算符函数, 其左操作数与隐式`this`形参绑定, 其右操作数(如果有的话)作为显式实参传递

特别的, 拷贝赋值运算符是指右操作数的类型与左操作数相同时的赋值运算符; 

* 在定义类的拷贝赋值运算符时, 该运算符函数接受一个同类型的实参
* 为了与内置类型的赋值保持一致, 赋值运算符通常返回一个指向其左操作数的引用
  * 值得注意的是, 标准库要求保存在容器中的类型要具有赋值运算符, 且其返回值是左操作数的引用

### 合成拷贝赋值运算符

如果类未定义自己的拷贝赋值运算符, 编译器会为它合成一个;

合成拷贝赋值运算符的行为

* 对于某些类, 合成拷贝赋值运算符用来禁止该类型对象的赋值
* 其他情况下, 合成拷贝赋值运算符将右操作数的每个非静态成员赋予左操作数的对应成员; 这一工作是通过成员类型的拷贝赋值运算符来完成. 返回一个指向左操作数的引用
  * 对于数组类型的成员, 逐个赋值数组元素

## 1.3析构函数*

析构函数(**destructor**), 释放对象所使用的资源和销毁对象的非静态成员, 以及做一些相关所需的工作

* 析构函数是类的特殊的成员函数
  * 名字由`~`加类名组成, 没有返回值, 也不接受形参
  * 有函数体和析构部分
  * 形式: `~class_name()`
* 析构函数不能被重载, 因为没有形参

### 析构函数的工作

在析构函数中, 首先执行其函数体, 然后销毁成员; 成员按照初始化顺序的逆序销毁

* 在函数体中是在该对象销毁前希望执行的工作; 通常, 是释放该对象分配的所有资源

* 析构函数的销毁部分是隐式的, 如何销毁对象的成员取决于成员的类型
  * 内置类型: 直接销毁内置成员
    * 内置类型没有析构函数, 因此在销毁内置类型的成员之前什么也不需要做, 
  * 类类型: 通过执行类类型成员的析构函数来销毁该成员

### 何时调用析构函数

在一个类的对象被销毁时, 都会自动调用其析构函数, 包括:

* 变量在离开其作用域时被销毁
* 当一个对象被销毁时, 其成员被销毁
* 容器被销毁时其元素被消耗
* 当`delete`一个指向动态对象的指针时, 该动态对象被销毁
* 当整个表达式结束时, 其中被创建的临时对象被销毁

### 合成析构函数

当类没有定义析构函数时, 编译器为它合成一个;

合成析构函数(**the synthesized destructor**)

* 行为:
  * 对于某些类, 合成析构函数用来阻止该类型的对象被销毁
  * 其他情况下, 合成析构函数有一个空的函数体

## 1.4三五原则*

拷贝控制有五个操作: 

* 拷贝构造函数, 拷贝赋值运算符, 析构函数
* (C++11) 移动构造函数, 移动赋值运算符

C++语言并没有要求我们必须定义所有这些操作; 我们可以定义其中的零个或多个操作. 但是, 这些操作通常被看作一个整体; 一般情况下, 当类需要定义其中一个操作, 往往也需要定义其他操作

确定一个类是否要定义自己的拷贝控制成员时的一些经验

* 如果类需要析构函数, 几乎可以确定它也需要拷贝构造函数和拷贝赋值运算符
* 如果类需要拷贝构造函数, 几乎可以确定它也需要拷贝赋值运算符, 反之亦然

## 1.5使用`=default`(C++11)

可以使用`=default`显式地要求编译器生成拷贝控制成员的合成版本

* 在类的内部使用`=default`, 合成函数是隐式`inline`
* 在类外部的成员定义使用`=dfault`, 合成函数不是`inline`

注意: `=default`只能用于有合成版本的成员函数, 如拷贝控制成员, 默认构造函数

## 1.6阻止拷贝

对于某些类来说, 拷贝操作是没有合理的含义. 在这种情况下, 定义类时必须采用某种机制阻止拷贝或赋值. 例如, `iostream`类阻止了拷贝, 以避免多个对象写入或读取相同的IO缓冲

### 定义删除的函数(C++11)

在C++11下, 将拷贝构造函数和拷贝赋值运算符定义为删除的函数(**deleted function**), 能够阻止对象的拷贝.

* 形式: 在函数的形参列表后面加上`=delete`

  ```c++
  struct NoCopy {
      NoCopy() = default;
      NoCopy(const NoCopy&) = delete;
      NoCopy &operator=(const NoCopy&) = delete;
      ~NoCopy() = default;
  };
  ```

* `=delete`告诉编译器不要定义这些成员; 因此函数被声明为删除后, 程序中没有对应的实体, 也不能在程序中以任何方式使用它;
* 说明: 
  * 与`=default`不同, `=delete`只能出现在函数第一次声明的时候;
  * 与`=default`不同, 可以对任何函数指定`=delete`
  * 删除的析构函数
    * 对于一个删除了析构函数的类型, 编译器不允许定义该类型的变量或创建该类型的临时对象; 而且如果一个类有某个成员的类型删除了析构函数, 也不能定义该类型的变量或临时对象
    * 对于一个删除了析构函数的类型, 可以动态分配该类型的对象, 但是不能释放这些对象

### 合成成员函数可能是删除的

如果一个类有数据成员不能默认构造, 拷贝, 赋值或销毁, 则对应的合成成员函数被定义为删除

具体为

* 类的合成析构函数被定义为删除的情况
  * 某个成员自己的析构函数是删除的或不可访问的
* 类的合成拷贝构造函数被定义为删除的情况
  * 某个成员的拷贝构造函数是删除的或不可访问的
  * 某个成员的析构函数是删除的或不可访问的
* 类的合成拷贝赋值运算符被定义为删除的情况
  * 某个成员的拷贝赋值运算符是删除的或不可访问的
  * 该类有一个`const`或引用成员
* 类的合成默认构造函数被定义为删除的情况
  * 某个成员自己的析构函数是删除的或不可访问的
  * 某个成员自己的默认构造函数是删除的或不可访问的, 且该成员没有类内初始符
  * 该类有一个引用成员, 该成员没有类内初始符
  * 该类有一个`const`成员, 该成员的类型没有显式地定义默认构造函数且没有类内初始符

### `private`拷贝控制

C++11之前的阻止拷贝的方法

* 声明并且定义`private`的拷贝构造函数和拷贝赋值运算符
  * 用户不能访问`private`成员, 但友元和成员可以访问, 此时友元和成员可以进行拷贝
* 声明但不定义`private`的拷贝构造函数
  * 除了s15.2.1 p594的例外, 声明但不定义一个成员函数是合法的; 而所有试图使用一个未定义的成员将导致一个链接时错误
  * 因此, 这样做的话可以预先阻止任何拷贝该类型对象的企图
    * 试图拷贝对象的用户代码将在编译阶段被标记为错误
    * 成员函数或友元函数中的拷贝操作将会导致链接时错误

# 2.拷贝控制和资源管理*

通常, 管理在类外资源的类必须定义拷贝控制成员; 这种类需要通过析构函数来释放对象所分配的资源, 而需要析构函数的类也几乎肯定需要自己的拷贝构造函数和拷贝赋值运算符

在定义这些函数之前, 我们首先确定此类型对象的拷贝语义; 一般来说, 有两种选择

* 拷贝操作使类的行为像一个值; 例如, 标准库容器和`string`
  * 像值的类都有自己的状态; 当拷贝一个像值的对象时, 副本对象和原对象是完全独立的; 改变副本不会对原对象有任何影响, 反之亦然
* 拷贝操作使类的行为像一个指针; 例如, `shared_ptr`
  * 像指针的类共享状态; 当拷贝一个像指针的对象时, 副本对象和原对象使用相同的底层数据; 改变副本会改变原对象, 反之亦然

为了说明这两种方式, 以`HasPtr`类为例子, 为`HasPtr`定义拷贝控制成员. 首先, 令其的行为像一个值; 然后重新实现`HasPtr`类使其的行为像一个指针

* `HasPtr`类有两个成员, 一个`int`类型变量`i`和一个指向`string`的指针`ps`

### 2.1像值的类Classes that ack like values*

为了提供类值(**valuelike**)的行为, 对于类管理的资源, 每个对象都应该拥有一份自己的拷贝;

* 因此, 每个`HasPtr`对象必须都有一份`ps`指向的`string`的拷贝.
  * 拷贝构造函数中要拷贝`string`对象, 而不是拷贝指针
  * 析构函数中要释放`string`对象
  * 拷贝赋值运算符中, 释放当前已有的`string`对象, 拷贝右操作数中的`string`对象

```c++
class HasPtr {
public:
    HasPtr(const std::string &s = std::string):
    	ps(new std::string(s)), i(0) { }
    HasPtr(const HasPtr &p):
    	ps(new std::string(*p.ps), i(p.i) { }
	HasPtr& operator=(const HasPtr &);
    ~HasPtr() {delete ps;}
private:
    std::string *ps;
    int	i;
};
           
HasPtr& operator=(const HasPtr &rhs)
{
    auto newp = new string(*rhs.ps);
    delete ps;
    ps = newp;
    i = rhs.i;
    return *this;
}
```

编写拷贝赋值运算符的代码时, 要确保一个对象赋予它自身时也能正确操作; 如果可能, 编写的运算符应该是异常安全的----当异常发生时能将左操作数置于一个有意义的状态

* 在本例中, 通过先拷贝右操作数, 使得拷贝赋值运算符可以处理自赋值情况, 并能保证在异常发生时代码是安全的

### 2.2像指针的类Classes that ack like pointers*

为了提供类指针的行为, 类的拷贝构造函数和拷贝赋值运算符应该拷贝指针成员本身, 而不是它指向的资源

* 令一个类的行为类似于指针的最好方法是使用`shared_ptr`来管理类中的资源;
* 如果希望直接管理资源, 使用引用计数是不错的选择

### 引用计数

引用计数的工作方式如下

* 除了初始化对象外, 每个构造函数(拷贝构造函数除外)还要创建一个引用计数, 用来记录右多少对象与正在创建的对象共享状态. 当创建一个对象时, 只有一个对象共享状态, 因此将计数器初始化为1
* 拷贝构造函数不分配新的计数器, 而是拷贝给定对象的数据成员, 包括计数器. 拷贝构造函数递增共享的计数器, 表示给定对象的状态又被一个新用户所共享
* 析构函数递减计数器, 表示共享状态的用户少了一个. 如果计数器变为0, 则析构函数释放状态

* 拷贝赋值运算符递增右操作数的计数器, 递减左操作数的计数器. 如果左操作数的计数器为0 , 拷贝赋值运算符就必须销毁状态

在哪里存放引用计数

* 其中一种方式是, 将计数器保存在动态内存中

### 定义一个使用引用计数的类

```c++
class HasPtr {
public:
    HasPtr(const std::string &s = std::string) :
    	ps(new std::string(s)), i(0), use(new std::size_t(1)){ }
    HasPtr(const HasPtr &p) :
    	ps(p.ps), i(p.i), use(p.use) { ++*use; }
    HasPtr &operator=(cosnt HasPtr&);
  	~HasPtr();
private:
    std::string sp;
    int i;
    std::size_t *use;
};

HasPtr::~HasPtr()
{
    if (--*use == 0) {
        delete ps;
        delete ust;
	}	
}

HasPtr &operator=(const HasPtr& rhs)
{
    ++*rhs.use;
    if (--*use == 0) {
        delete ps;
        delete use;
    }
    ps = rhs.ps;
    i = rhs.i;
    use = rhs.use;
    return *this;
}
```

# 3.交换Swap*

除了定义拷贝控制成员时, 管理资源的类通常定义一个名为`swap`的函数

* 对于打算用于重排元素顺序的算法的类, 定义`swap`十分重要; 
* 这类算法在需要交换元素时会调用`swap`函数; 如果类有自己的`swap`函数, 算法将使用类自定义的版本; 如果没有则使用标准库中的`swap`函数

为了交换两个对象, 需要进行一次拷贝和两次赋值; 如下是类值`HasPtr`

```c++
HasPtr temp = v1;
v1 = v2;
v2 = temp;
```

* 例子中, `v1`中的`string`对象被拷贝两次: 一次是将`v1`拷贝初始化`temp`, 一次是赋值运算符将`temp`赋予`v2`
* 将`v2`赋予`v1`的语句拷贝了一次原来`v2`中的`string`

理论上, 上面例子中的内存分配都是不必要的; 我们更希望`swap`交换指针; 如下

```c++
string *temp = v1.ps;
v1.ps = v2.ps;
v2.ps = temp;
```

### 编写自己的`swap`函数

```c++
class HasPtr {
    friend void swap(HasPtr&, HasPtr&);
    // other member as before
};
inline
void swap(HasPtr &lhs, HasPtr &rhs)
{
    using std::swap;
    swap(lhs.ps, rhs.ps);
    swap(lhs.i, rhs.i);
}
```

### 在`swap`函数中调用`swap`, 而不是`std::swap`

在`swap`函数中调用`swap`, 而不是`std::swap`, 而且使用`using`声明标准库的`swap`: `using std::swap`

* 在函数匹配中, (如果有的话)类型特定的`swap`是优于标准库中的`swap`;
* 使用`using std::swap`后, 名字`swap`可以指向标准库的`swap`函数

* 因此, 在函数匹配时
  * 如果存在类型特定的`swap`, 那么类型特定的`swap`是最佳匹配
  * 如果不存在类型特定的`swap`, 那么标准库的`swap`是最佳匹配

### 在赋值运算符中使用`swap`

定义`swap`的类通常使用`swap`来定义它们的赋值运算符, 使用一种名为拷贝并交换(**copy and swap**)的技术

* 具体为: 将左操作数与右操作数的拷贝交换

  ```c++
  HasPtr& HasPtr::operator=(HasPtr rhs)
  {
      swap(*this, rhs);
      return *this;
  }
  ```
  * 例子中, 右操作数被值传递到形参`rhs`中, 因此`rhs`是右操作数的拷贝; 然后将左操作数`*this`和右操作数的拷贝`rhs`交换

* 拷贝并交换这一技术的有趣之处是, 它自动处理了自赋值情况并且也是异常安全的
  * 在改变左操作数之前拷贝右操作数, 这保证了自赋值的正确;
  * 代码唯一可能抛出异常的是拷贝右操作数时的拷贝构造函数中的`new`表达式; 它在改变左操作数之前才可能发生

# 4.拷贝控制的示例(p519)

# 5.管理动态内存的类(p524)

`move`函数, 定义在`utility`头文件中

# 6.移动对象(C++11)

在某些情况下, 对象拷贝后就立即被销毁; 此时, 移动而非拷贝对象会大幅度提升性能

* 标准库容器, `stirng`和`shared_ptr`类都支持移动操作和拷贝操作
* IO和`unique_ptr`类支持移动操作, 不支持拷贝操作

## 6.1右值引用

为了支持移动操作, C++11引入一种新的引用类型, 右值引用(**rvalue reference**);

右值引用, 是必须绑定到右值的引用

* 通过`&&`来获得右值引用
* 右值引用只能绑定到一个将要销毁的对象; 因此, 能够将右值引用的资源"移动"到其他对象

## 6.2移动构造和移动赋值

## 6.3右值引用和成员函数