

# 总结

表达式是由一个或多个运算符组成的.([汇总](#12.汇总))

* 各种运算符的用法, 优先级, 结合律, 求值顺序
* 类型转换: 隐式转换(自动转换), 显式转换

---

[toc]

# 1.表达式基础

表达式由可选的运算符和一个或多个运算数（**operands**)组成; 对表达式求值时得到一个结果.

* 字面值和变量就是最简单的表达式, 其结果是它们自己的值. (没有运算符, 只有一个运算数)

## 1.1基本概念*

* 运算符按操作数的多少可分为:
  *  一元运算符(**unary operator**)
  * 二元运算符(**binary operator**)
  * 三元运算符(**ternary operator**)

* 运算符和操作数的组合
  * 对于含有多个运算符的复杂表达式来说, 要想求值需要解决这个关键问题: 运算顺序. 所以有关于运算符的一些规则
    * 运算符的优先级(**precedence**), 结合律(**associativity**)
    * 操作数的求值顺序(**order of evaluation**)

* 操作数的转换
  * 表达式求值时, 经常需要把操作数从一种类型转换另一种类型. 
* 重载运算符(**overloaded operator**)
  * C++定义了运算符作用于内置类型和复合类型的对象时所执行的操作/含义.
  * 运算符作用于类类型的对象时, 用户可以自行定义其含义; 因为运算符被赋予更多的意义, 所以被称为**重载运算符**.
  * 注意: 不能改变运算符的优先级和结合律, 还有操作数的数量.

* 左值(**Lvalue**)和右值(**Rvalue**)
  * 对象可以分为左值和右值.
    * 在C中, 左值是能够放在赋值语句左侧的值, 右值是不能放在赋值语句左侧的值.
    * 在C++中, 二者的区别就没那么简单了. 粗略地讲, 当一个对象被用作右值时, 用的是对象的值(它的内容); 当对象被用作左值时, 用的是对象的identity(它在内存中的位置).
  * 在运算符需要右值的地方可以使用左值, 反之不然.
  * 使用`decltype`时, 左值和右值有所不同; 左值: 相应的引用类型; 右值: 相应的类型

## 1.2优先级和结合律

复合表达式(**compound expression**)是指含有两个或以上运算符的表达式.

在复合表达式的求值过程中首先需要将运算符和操作数组合在一起. 而优先级(**precedence**)和结合律(**associativity**)决定了操作数组合的方式. 

* 优先级: 运算符的优先级越高, 运算符越先与操作数结合 
  * 优先级只是规定了运算符与对象的组合顺序, 并没有说明操作数按照什么顺序求值.
* 结合律: 在优先级相同时, 结合律决定运算符的结合顺序(从左向右, 或从右向左)
* 小括号可以无视上述的组合规则; 表达式中被括起来的部分被当成一个单元来求值, 然后再与其他部分一起按照默认组合规则来组合.
* 例子: ` 6+3*4/2-2` : `*`和`/`运算符的优先级比`+`,`-`的高; 而`*`和`/`有相同的优先级, 根据它们的结合律(左结合律), 应该从左向右结合. 因此式子等于`((6+((3*4)/2))-2)`

### 1.3求值顺序

大多数的运算符并没有规定求值顺序; 不能假设求值顺序, 因为求值顺序是未定义的.

* 对于没规定求值顺序的运算符, 如果表达式指向并修改同一个对象, 将引发错误并产生未定义的行为. 例子, `<<`运算符没有规定求值顺序

* ```c++
  int i = 0;
  cout << i << " " << ++i << endl;	// undefined
  ```

优先级规定了操作数的组合方式, 但是没有说明操作数按照什么顺序求值. 也就是说, 求值顺序是与优先级, 结合律无关.

* 例如: `int i = f1() * f2();`, 可以知道`()`函数调用运算符的优先级更高, 所以`f1()`和`f2()`是在执行乘法之前执行的. 但是, 我们无法知道`f1`和`f2`函数哪个先调用.
* `f() + g() * h() +j()`; 
  * 优先级规定了`g()`的返回值和`h()`的返回值相乘
  * 结合律规定了`f()`和`g()*h()`的乘积相加, 所得结果再与`j()`的返回值相加
  * `+`, `*`都没有规定求值顺序, 所以这四个函数的调用顺序是未定义的. 
  * 如果这些函数是不相干的函数, 即不会影响到同一个对象的状态, 那么该表达式是不受求值顺序影响的; 如果其中有函数影响到同一对象, 这是一条错误的表达式.

明确规定求值顺序的4种运算符

* 逻辑与运算符`&&`: 保证先求左操作数的值; 而且只有左操作数的值为`true`时才继续求右操作数的值
* 逻辑或运算符`||`: 保证先求左操作数的值; 而且只有左操作数的值为`false`时才继续求右操作数的值
* 条件运算符`?:`: 保证先求第一操作数的值; 根据第一操作数的值来决定下一个被求值的操作数
* 逗号运算符`,`: 保证先求左操作数的值, 再求右操作数的值

# 2.算术运算符Arithmetic Operators

**算术运算符:** 

* 表格以优先级分组, 从高到低排序; 都是左结合律

| 运算符 |   功能   |     用法      | 说明                                         |
| :----: | :------: | :-----------: | -------------------------------------------- |
|  `+`   | 一元正号 |   `+ expr`    | 返回操作数的值的一个(可能被提升的)副本       |
|  `-`   | 一元负号 |   `- expr`    | 对操作数的值取负后, 返回其(可能被提升的)副本 |
|        |          |               |                                              |
|  `*`   |   乘法   | `expr * expr` |                                              |
|  `/`   |   除法   | `expr / expr` | 若操作数是整型, 返回值也是整型               |
|  `%`   |   求余   | `expr % expr` | 只用于整数类型                               |
|        |          |               |                                              |
|  `+`   |   加法   | `expr + expr` |                                              |
|  `-`   |   减法   | `expr - expr` |                                              |

* 操作数可以是任意算术类型以及任意能转换为算术类型的类型. 
  * 其中, 一元正号, 加法和减法运算符都能作用于指针;
* 操作数和求值结果都是右值
* 小整数类型的操作数会被提升成更大的整数类型; 所有操作数最终会转换成同一类型.

**具体说明:**

`/`除法运算符

* 整数间的除法返回一个整数; 商的小数部分直接弃除.
  * C++早期版本允许结果为负值的商向上或向下取整; C++11标准规定商一律向0取整(即直接切除小数部分)
* 操作数的符号相同, 且商不为0时, 商为正, 否则为负.

`%`求余运算符: C++中求余运算符也称为取模运算符

* 操作数必须是整数类型
* C++定义的取模操作是指, 如果`m`和`n`都是整数, `n`不为零, 那么`(m / n) * n + m % n`等于`m`;
  * 由定义可得, 若`m % n`不为0时, 它的符号和`m`相同.
    * 如果`-m`不会导致溢出, 则有`m % (-n)`等于`m % n`, `(-m) % n`等于`-(m % n)`
  * 现在禁止的规则: C++早期版本允许`m % n`匹配`n`的符号, 如果该实现的`m / n`的负值商向负无穷取整

**注意:**

* `bool`类型的值最好不要参与运算; 如: 对`true`取负, 结果仍然为`true`.

  * ```c++
    bool b = true;
    bool b2 = -b;	// b2 is true!
    ```

  * 解释: 在求值时, `bool`类型的操作数将被提升为`int`类型, `bool`值`true`被提升为`int`值`1`, `bool`值`false`被提升为`int`值`0`. 

  * 例子中,  `-b`表达式中 `b`的值变成`1`, 然后对`1`取负得到`-1`, 所以`-b`的返回值是`-1`, 也就是`b2`的初始符. 在布尔类型初始化时, 非零初始符将转换成布尔值`true`

* 注意表达式是否溢出(**overflow**)

# 3.逻辑和关系运算符Logical and Relational Operators

**逻辑和关系运算符:**

* 表格以优先级分组, 从高到低排序; 

| 结合律 | 运算符 | 功能       | 使用           | 说明             |
| ------ | ------ | ---------- | -------------- | ---------------- |
| Right  | `!`    | 逻辑非     | `!expr`        | 对操作数的值取反 |
|        |        |            |                |                  |
| Left   | `<`    | 小于       | `expr < expr`  |                  |
| Left   | `<=`   | 小于或等于 | `expr <= expr` |                  |
| Left   | `>`    | 大于       | `expr > expr`  |                  |
| Left   | `>=`   | 大于或等于 | `expr >= expr` |                  |
|        |        |            |                |                  |
| Left   | `==`   | 相等       | `expr == expr` |                  |
| Left   | `!=`   | 不相等     | `expr != expr` |                  |
|        |        |            |                |                  |
| Left   | `&&`   | 逻辑与     | `expr && expr` |                  |
|        |        |            |                |                  |
| Left   | `||`   | 逻辑或     | `expr || expr` |                  |

* 关系运算符
  * 其操作数是算术或指针类型的右值
  * 其结果是布尔类型的右值
* 逻辑运算符
  * 其操作数是任意可转换成布尔类型的右值
  * 其结果是布尔类型的右值

**具体说明:**

* `&&`逻辑与运算符, `||`逻辑或运算符
  * `&&`逻辑与运算符: 当且仅当两个操作数都为`true`时结果为`true`
  * `||`逻辑或运算符: 只要有一个操作数为`true`, 其结果为`true`
  * 求值顺序: 先计算左操作数的值, 然后根据左操作数的结果无法确定表达式的结果时, 才会计算右操作数的值.  这种策略称为短路求值(**short-circuit evaluation**).
    * `&&`逻辑与运算符:  当左操作数为`true`时才对右操作数求值
    * `||`逻辑或运算符: 当左操作数为`false`时才对右操作数求值

# 4.赋值运算符Assignment Operators

`=`赋值运算符: 

* 其左操作数必须是可修改的左值
* 其右操作数是右值.
  * 如果左右操作数的类型不相同, 右操作数被转换成左操作数的类型; 如果不允许这种类型转换, 则表达式报错.
  * 在C++11标准下, 右操作数可以是花括号括起的初始符列表; 
    * 初始符列表可为空, 那么编译器会生成已值初始化的临时对象, 并将临时对象赋给左操作数.
    * 若左操作数是内置类型, 初始符列表最大只能包含一个值, 且该值不需要进行收缩转换(**narrowing conversion**)
    * 若左操作数是类类型, 赋值运算取决于类本身.
* 结果是左操作数, 并且是一个左值; 结果的类型是左操作数的类型.
* 赋值运算是右结合的
  * 在多重赋值语句中, 每对相邻的对象需要满足以下条件之一
    * 两对象是相同类型的
    * 右侧对象的类型可以转换为左侧对象的类型.

复合赋值运算符: 

* 都为左结合

* 算术复合赋值运算符: `+=`, `-=`, `*=`, `/=`, `%=`
* 位复合赋值运算符: `<<=`, `>>=`, `&=`, `^=`, `|=`
* `a op= b` 基本等于`a = a op b` ; 不同的是, 复合赋值中左操作数只被求值一次, 而普通的赋值中左操作数被求值两次.

注意:

* 切勿混淆赋值运算符`=`和相等运算符`==`

# 5.递增和递减运算符Increment and Decrement Operators

`++`递增运算符和`--`递减运算符

* 前置版本`++obj`, `--obj`: 
  * 右结合
  * 接受一个左值, 递增(递减)运算对象; 结果是**改变后**的对象, 是一个左值
* 后置版本`obj++`, `obj--`: 
  * 左结合
  * 接受一个左值, 递增(递减)运算对象; 结果是**改变前**的对象的副本, 是一个右值

# 6.成员访问运算符The Member Access Operators

两种提供成员访问的运算符: `.`点运算符和`->`箭头运算符

`.`点运算符

* 作用: 从一个类对象中获取一个成员
* 结合律: 左结合

* 用法:`obj.mem`
* 结果: 类对象的成员的引用, 是一个左值

`->`箭头运算符

* 作用: 从一个指向类对象的指针中获得一个成员,等价于`(*ptr).mem`
* 结合律: 左结合

* 用法:`ptr->mem`
* 结果: 类对象的成员的引用, 是一个左值

# 7.条件运算符The Conditional Operator

`?:`条件运算符:

* 作用: 允许把简单的if-else逻辑嵌入到单个表达式中
* 结合律: 右结合
* 用法:`cond ? expr1 : expr2`
  * 先对`cond`求值; 当`cond`为`true`时, 对`expr1`求值, 否则对`expr2`求值
  * `expr1`和`expr2`表达式要么拥有相同的类型, 要么能转换为某个共同的类型
* 结果
  * 结果是左值的情况
    * `expr1`和`expr2`是左值时
    * `expr1`和`expr2`能够转换为某个共同的左值类型
  * 在其他情况下, 结果是右值

**注意:**

* 嵌套条件运算符: 条件表达式可以作为另外一个条件运算符的`cond`或`expr`.
* 

# 8.位运算符Bitwise Operators

**位运算符**

* 表格以优先级分组, 从高到低排序; 

| 运算符 | 功能   | 用法             |
| ------ | ------ | ---------------- |
| `~`    | 位求反 | `~expr`          |
|        |        |                  |
| `<<`   | 左移   | `expr1 << expr2` |
| `>>`   | 右移   | `expr1 >> expr2` |
|        |        |                  |
| `&`    | 位与   | `expr & expr`    |
|        |        |                  |
| `^`    | 位异或 | `expr ^ expr`    |
|        |        |                  |
| `|`    | 位或   | `expr | expr`    |

* 位运算符把运算对象看成二进制的集合; 位运算符提供检查和设置二进制位的功能. 
  * 标准库类型`bitset`是用于表示任意大小的二进制位集合, 定义了位运算符.
* 位运算符的操作数类型是整数类型

**具体说明:**

**移位运算符**(**Bitwise Shift Operators**): `<<`左移运算符和`>>`右移运算符

* 作用: 把左操作数按照右操作数的要求移动指定位数
* 结合律: 左结合
* 用法: `integer << unsigned_integer`, `integer >> unsigned_integer`
* 结果: 经过移动后的(可能被提升的)左操作数的拷贝, 是一个右值
* 要求: 右操作数一定不能为负, 而且值比兴严格小于结果的位数, 否则会产生未定义的行为
* 具体细节:
  * 被移出边界之外的位都被舍弃掉
  *  `<<`运算符在右侧插入值为0的二进制位; 
  * `>>`运算符的行为取决于左操作数的类型
    * 无符号类型: 在左侧插入值为0的二进制位; 
    * 带符号类型: 在左侧插入值为0的二进制位, 或插入符号位的值; 由实现来选择哪种结果

**位求反运算符**: `~`运算符

* 作用: 将操作数逐位取反, 则将1置为0, 将0置为1
* 结合律: 右结合
* 用法: `~expr`
* 结果: 求反后的一个新的右值

**位与, 或, 异或运算符**: `&`运算符, `|`运算符, `^`运算符

* 作用: 在两个操作数上逐位执行相应的逻辑操作
* 结合律: 左结合
* 用法: `expr & expr`, `expr | expr`, `expr ^ expr`
* 结果: 逻辑操作后的一个新的右值
* 具体细节
  * `&`运算符: 两个操作数的对应位置都是1, 则运算结果中该位置为1, 否则为0
  * `|`运算符: 两个操作数的对应位置都是0, 则运算结果中该位置为0, 否则为1
  * `^`运算符: 两个操作数的对应位置有且只有一个为1, 则运算结果中该位置为1, 否则为0

**注意:**

* 标准没有规定位运算符如何处理符号位, 因此最好仅将位运算符用于处理无符号类型
  * 如果运算对象是带符号的, 其值为负, 那么位运算符如何处理该运算对象是机器相关的; 此时的左移操作可能会改变符号位的值, 这是一种未定义的行为.

  

# 9.sizeof运算符

`size of`运算符

* 作用: 返回一个表达式的返回类型或一种类型所占的字节数,
* 结合律: 右结合
* 用法: `sizeof (type)`, `sizeof expr`
* 结果: 表示字节数的`size_t`类型的常量表达式
* 具体细节:
  * `sizeof`运算符不会对操作数求值
    * 如`sizeof *p`, 该表达式不会解引用`p`指针, 所以`p`就算是一个无效的指针也不会有影响
  * (C++11)在`sizeof`运算符中, 允许使用`::`运算符来获取类成员的大小, 不需要提供具体的对象
    * `sizeof string::empty`; 其中`string`是类类型, `empty`是一个成员函数.
  * `sizeof`运算符的结果部分地依赖于其作用的类型
    * `sizeof char`的结果保证为1
    * `sizeof`一个引用类型, 得到被引用对象的字节数
    * `sizeof`一个指针, 得到指针本身的字节数
    * `sizeof`一个解引用指针, 得到被指的对象的字节数; 指针不需有效
    * `sizeof`一个数组, 得到数组的字节数; 在这里使用数组不会转换为指向首元素的指针
    * `sizeof`一个类类型, 得到其类型固定部分的大小; 不会计算对象中的元素占用的空间

# 10.逗号运算符Comma Operator

`,`逗号运算符

* 作用: 保证求值顺序; 先对左操作数求值, 再对右操作数求值
* 结合律: 左结合律
* 用法: `expr, expr`
* 结果: 右操作数的值; 如果右操作数是左值类型, 则结果是左值, 否则为右值

# 11.类型转换*

关联类型与类型转换, **related type and conversion**

* 在C++中, 在需要某种类型的对象的地方, 可以用与该类型有关联的类型的对象或值来替代; 换句话说, 两种类型是关联的(related), 意味着这两种类型之间存在某种类型转换.

隐式类型转换/隐式转换(**implicit conversion**)

* 隐式转换, 是指根据规则自动执行的类型转换, 无须程序员的介入
* 发生隐式转换的情况
  * 在大多数表达式中, 小整型值首先进行整型提升(**integral promotion**)
  * 在条件中, 非布尔表达式转换成布尔类型
  * 在初始化中, 初始符转换成变量的类型
  * 在赋值中, 右操作数转换成左操作数的类型
  * 在算术和关系表达式中, 如果操作数类型不同, 两操作数转换成统一的类型
  * 在函数调用时的隐式转换(详见第六章)

显式类型转换/显式转换(**explicit conversion**)

* 显式转换: 强制将一个对象转换成另一种类型

## 11.1算术转换*

整型提升(**Integral Promotions**)

* 整型提升, 是指将某些小整型转换成更大的整型的类型转换; 
* 在大多数表达式中, 小整型都会进行提升, 无论操作数类型是否一样
* 对于`bool`, `char` , `signed char`, `unsigned char`, `short`, `unsigned short`等类型 
  * 如果这些类型的所有可能值能够存入`int`中的话, 那么它们会提升到`int`类型, 
  * 否则它们会提升成`unsigned int`类型
* 对于较大的`char`类型, 即`wchar_t`, `char16_t`, `char32_t`等类型, 在满足提升后的类型能容纳原类型中所有可能值的前提下, 选择以下最小的类型:
  * `int`, `unsigned int`, `long`, `unsigned long`, `long long`, `unsigned long`

在算术运算符中操作数的算术类型不同时的类型转换: 

* 操作数类型不一致时, 将会执行以下类型转换, 直至两者的类型一致.

  1. 整型提升

  2. 判断类型的符号性

     * 如果都为无符号类型, 或都为带符号类型, 则将较小的类型转换成较大的类型

     * 如果一个是无符号类型, 一个是带符号类型, 有
       * 无符号类型大于等于带符号类型, 则将带符号类型转换成无符号类型
       * 无符号类型小于带符号类型, 则结果是依赖于机器; 如果无符号类型的所有值能放入带符号类型中, 则将无符号类型转换成带符号类型, 否则将带符号类型转换成无符号类型
       

* 例子: 假设表达式中有`long`和`unsigned int`类型的操作数; 
  * 首先不需要进行提升, 
  * 符号类型不同, 而且标准保证了`long`是大于等于`int`的. 因此有两种情况:
    * 在`long`大于`int`的实现中, `unsigned int`操作数转换成`long`类型
    * 在`long`等于`int`的实现中, `long`操作数转换成`unsigned int`类型

* 对应的流程图
  ```mermaid
  graph TB
  A[整型提升]-->B{signedness?}
  B-->|same| C[小类型->大类型]
  B-->|different| D{无符号>=有符号?}
  D-->|Yes| E[有符号类型->无符号]
  D-->|No| M[result is machine dependent]
  M-->F{无符号能放进有符号类型?}
  F-->|Yes| G[无符号类型->有符号]
  F-->|No| H[有符号类型->无符号]
  ```

## 11.2其他隐式转换

数组转换成指针

* 绝大多数情况下, 数组类型的名字自动转换指向首元素的指针

* 以下情况不会执行该转换
  * `decltype`
  * 取地址符`&`
  * `sizeof`
  * `typeid`
  * 初始化一个指向数组的引用时; 

指针的转换: 几种其他的指针转换

* 值为0的常量整数值, 和字面值`nullptr`可以转换成任意指针类型
* 指向非`const`类型的指针可以转换成`void*`类型
* 任意指针都可以转换成`const void*`类型
* (见s15.2.2 p597)

转换成布尔类型

* 从算法类于或指针类型转换成布尔类型的自动转换; 常见于条件中
* 如果指针或算术类型的值为0, 则转换成`false` ; 否则转换成`true`

转换成`const`类型

* 指向非`const`类型的指针可以转换成指向相应的`const`类型的指针
* 指向非`const`类型的引用可以转换成指向相应的`const`类型的引用

由类类型定义的转换

* 类类型可以定义由编译器自动执行的转换
* 编译器每次只执行一种类类型的转换

## 11.3显式转换

显式转换的方式, 叫做**强制类型转换(cast)**

* 强制类型转换干扰了正常的类型检查

* waring: Although necessary at times, casts are inherently dangerous constructs.

命名cast(**Named cast**)

* 用法: `cast-name<type>(expression)`

  * `type`是目标类型, `expression`是要被转换的值.
  * `cast-name`表示执行哪种转换, 有以下几种
    * `static_cast`
    * `dynamic_cast`: 
    * `const_cast`
    * `reinterpret_cast`

* `static_cast`: 可进行不改变底层`const`的任何类型转换; 常用场合:

  * 把较大的算术类于赋值给较小的类型; 
  * 把指针存放在`void*`指针中; 然后在需要时从`void*`指针赋值给原来类型的指针

* `const_cast`: 只能改变运算对象的底层`const`

  * 如果运算对象本身是`const`, 然后使用该转换并执行写操作, 就会产生未定义行为
  * 常用场合: 有函数重载的场合

* `reinterpret_cast`: 为运算对象的位模式提供较低层次上的重新解释

  * 该转换不会对运算对象的位模式进行任何改变; 直接把运算对象的位模式当作目标类型来使用

  * ```c++
    int *ip;
    char *pc = reinterpret_cast<char*>(ip);
    ```

  * `reinterpret_cast`本质上依赖于机器. 要想安全使用`reinterpret_cast`必须对涉及的类型和编译器实现转换的过程都非常了解

旧式cast(**old-style cast**)

* 用法: `type (expr)` , `(type) expr`
  * 根据所涉及的类型不同, 旧式cast分别具有`const_cast`, `static_cast`或`reinterpret_cast`相似的行为.
  * 当我们使用旧式cast时, 如果换成`const_cast`和`static_cast`也合法, 则其行为与对应的命名cast一致. 如果替换后不合法, 则旧式cast执行与`reinterpret_cast`类似的功能
* 与命名cast相比, 旧式cast容易被看漏, 表示的意思不那么清楚, 所以一旦转换过程出现问题, 更难追踪问题.

# 12.汇总

## 运算符的含义, 优先级和结合律

| 结合律 |      运算符      | 功能                       | 结果 | 用法| 重载 |
| ------ | :--------------: | :------------------------- | :--: | ----------------------- | ----------------------- |
| L      |       `::`       | 全局作用域                 |      | `::name`                |N|
| L      |       `::`       | 类作用域                   |      | `class::name`           |N|
| L      |       `::`       | 命名空间作用域             |      | `namespace::name`       |N|
|        |                  |                            |      |                         ||
| L      |       `.`        | 成员选择                   |  L   | `obejct.member`         |N|
| L      |       `->`       | 成员选择                   |  L   | `pointer->member`       |Y|
| L      |       `[]`       | 下标                       |      | `expr[expr]`            |Y|
| L      |       `()`       | 函数调用                   | L/R  | `name(expr_list)`       |Y|
| L      |       `()`       | 类型转换                   |  ?   | `type(expr_list)`       |?|
|        |                  |                            |      |                         ||
| R      |       `++`       | 后置递增运算               |  R   | `lvalue++`              |Y|
| R      |       `--`       | 后置递减运算               |  R   | `lvalue--`              |Y|
| R      |     `typeid`     | 类型ID                     |      | `typeid(type)`          |?|
| R      |     `typeid`     | 运行时类型ID               |      | `typeid(expr)`          |?|
| R      |  explicit cast   | 类型转换                   |  ?   | `cast_name<type>(expr)` |?|
|        |                  |                            |      |                         ||
| R      |       `++`       | 前置递增运算               |  L   | `++lvalue`              |Y|
| R      |       `--`       | 前置递减运算               |  L   | `--lvalue`              |Y|
| R      |       `~`        | 位求反                     |  ?   | `~expr`                 |Y|
| R      |       `!`        | 逻辑非                     |  R   | `!expr`                 |Y|
| R      |       `-`        | 一元负号                   |  R   | `-expr`                 |Y|
| R      |       `+`        | 一元正号                   |  R   | `+expr`                 |Y|
| R      |       `*`        | 解引用                     |      | `*expr`                 |Y|
| R      |       `&`        | 取地址                     |      | `&lavlue`               |X|
| R      |       `()`       | 类型转换                   |  ?   | `(type)expr`            |?|
| R      |     `sizeof`     | 对象的大小                 |  R   | `sizeof(expr)`          |?|
| R      |     `sizeof`     | 类型的大小                 |  R   | `sizeof(type)`          |?|
| R      |   `sizeof...`    | 参数包的大小               |      | `sizeof...(name)`       |?|
| R      |      `new`       | allocate object/分配对象   |      | `new type`              |Y|
| R      |     `new[]`      | allocate array/分配数组    |      | `new type[size]`        |Y|
| R      |     `delete`     | deallocate object/释放对象 |      | `delete expr`           |Y|
| R      |    `delete[]`    | 释放数组                   |      | `delete[] expr`         |Y|
| R      |    `noexcept`    | 能否抛出异常               |      | `noexcept(expr)`        |?|
|        |                  |                            |      |                         ||
| L      |      `->*`       | 指向成员选择的指针         |      | `ptr->*ptr_to_member`   |Y|
| L      |       `.*`       | 指向成员选择的指针         |      | `obj.*ptr_to_member`    |N|
|        |                  |                            |      |                         ||
| L      |       `*`        | 乘法                       |  R   | `expr*expr`             |Y|
| L      |       `/`        | 除法                       |  R   | `expr/expr`             |Y|
| L      |       `%`        | 取模(取余)                 |  R   | `expr%expr`             |Y|
|        |                  |                            |      |                         ||
| L      |       `+`        | 加法                       |  R   | `expr+expr`             |Y|
| L      |       `-`        | 减法                       |  R   | `expr-expr`             |Y|
|        |                  |                            |      |                         ||
| L      |       `<<`       | 位左移                     |  ?   | `expr<<expr`            |Y|
| L      |       `>>`       | 位右移                     |  ?   | `expr>>expr`            |Y|
|        |                  |                            |      |                         ||
| L      |       `<`        | 小于                       |  R   | `expr<expr`             |Y|
| L      |       `<=`       | 小于或等于                 |  R   | `expr<=expr`            |Y|
| L      |       `>`        | 大于                       |  R   | `expr>expr`             |Y|
| L      |       `>=`       | 大于或等于                 |  R   | `expr>=expr`            |Y|
|        |                  |                            |      |                         ||
| L      |       `==`       | 相等性                     |  R   | `expr==expr`            |Y|
| L      |       `!=`       | 不等性                     |  R   | `expr!=expr`            |Y|
|        |                  |                            |      |                         ||
| L      |       `&`        | 位与                       |  ?   | `expr&expr`             |Y|
|        |                  |                            |      |                         ||
| L      |       `^`        | 位异或                     |  ?   | `expr^expr`             |Y|
|        |                  |                            |      |                         ||
| L      |       `|`        | 位或                       |  ?   | `expr|expr`             |Y|
|        |                  |                            |      |                         ||
| L      |       `&&`       | 逻辑与                     |  R   | `expr&&expr`            |X|
|        |                  |                            |      |                         ||
| L      |       `||`       | 逻辑或                     |  R   | `expr||expr`            |X|
|        |                  |                            |      |                         ||
| R      |       `?:`       | 条件                       | L/R  | `expr?expr:expr`        |N|
|        |                  |                            |      |                         ||
| R      |       `=`        | 赋值                       |  L   | `lvalue=expr`           |Y|
| R      | `*=`, `\=`, `%=` | 复合赋值                   |  L   | `lvalue+=expr`等        |Y|
| R      |    `+=`, `-=`    | 同上                       |  L   |                         |Y|
| R      |  `<<=`, `>>=`,   | 同上                       |  L   |                         |Y|
| R      |  `&=`,`=`, `^=`  | 同上                       |  L   |                         |Y|
|        |                  |                            |      |                         ||
| R      |     `throw`      | 抛出异常                   |  ?   | `throw expr`            |?|
|        |                  |                            |      |                         ||
| L      |       `,`        | 逗号                       | L/R  | `expr, expr`            |X|

表格说明

* 以优先级分组, 从高到低排序
* 结合律以`L`和`R`表示左右结合律
* 结果以`L`和`R`表示左值和右值, `L/R`表示视情况而定, `?`表示未知
* 重载中的`Y`表示该运算符能够重载, `N`表示不能, `X`表示可以重载但不建议

## 求值顺序

明确规定求值顺序的4种运算符

* 逻辑与运算符`&&`: 保证先求左操作数的值; 而且只有左操作数的值为`true`时才继续求右操作数的值
* 逻辑或运算符`||`: 保证先求左操作数的值; 而且只有左操作数的值为`false`时才继续求右操作数的值
* 条件运算符`?:`: 保证先求第一操作数的值; 根据第一操作数的值来决定下一个被求值的操作数
* 逗号运算符`,`: 保证先求左操作数的值, 再求右操作数的值