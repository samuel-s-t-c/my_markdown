# 总结

* 拷贝, 赋值, 移动, 销毁; 拷贝控制成员是指拷贝, 赋值和销毁相关的成员函数
  * 拷贝构造函数, 拷贝赋值运算符
  * 移动构造函数, 移动赋值运算符
  * 析构函数
* 拷贝控制与资源管理




[toc]

# 前言

拷贝控制(**copy control**), 是指以下的操作

* 拷贝构造函数
* 拷贝赋值运算符
* 移动构造函数
* 移动赋值运算符
* 析构函数

如果一个类没有定义所有的拷贝控制成员, 则编译器自动定义缺失的操作

* 对于一些类来说, 不能依赖于这些操作的默认定义; 特别是需要自身管理动态内存的类

# 1.拷贝, 赋值和销毁

以最基本的操作作为开始

* 拷贝构造函数
* 拷贝赋值运算符
* 析构函数

## 1.1拷贝构造函数*

拷贝构造函数(**the copy constructor**), 是这样的构造函数, 它的第一个形参是自身类类型的引用, 其他形参都有默认值

* 第一个形参必须是引用类型; 通常是`const`引用

### 合成拷贝构造函数

如果在类没有定义一个拷贝构造函数, 编译器会替我们合成一个拷贝构造函数; 这个构造函数就是合成拷贝构造函数(**the synthesized copy constructor**)

* 注意:  只要是没有定义拷贝构造函数, 编译器就会定义一个合成拷贝构造函数; 即使定义了其他的构造函数, 也是一样
* 行为
  * 对于某些类, 合成拷贝构造函数用来阻止拷贝该类的对象;
  * 一般情况下, 合成拷贝构造函数将实参的成员逐个拷贝到正在创建的对象中; 成员的类型决定了如何复制该成员
    * 类类型的成员使用其拷贝构造函数
    * 内置类型的成员直接拷贝; 对于数组类型的成员, 合成拷贝构造函数会逐一拷贝数组成员中的元素 

### 拷贝初始化与直接初始化

区别

* 当我们使用直接初始化时, 我们要求编译器通过函数匹配来选择最佳匹配的构造函数

* 当我们使用拷贝初始化时, 我们要求编译器将右操作数拷贝到正在创建的对象中, 必要时进行类型转换, 即将右操作数转换为该类的类型

拷贝初始化通常使用拷贝构造函数来完成

* 如果该类有移动构造函数, 则拷贝初始化根据情况选择拷贝构造函数或移动构造函数.

发生拷贝初始化的情况

* 定义变量时使用`=`
* 将一个对象作为实参传递给一个非引用类型的形参
* 从一个返回类型为非引用类型的函数中返回一个对象
* 用花括号列表初始化一个数组中的元素或一个聚合类对象的成员

为什么拷贝构造函数的第一个形参必须是引用类型

* 如果该形参不是引用类型, 则初始化该形参时会使用拷贝初始化,  而拷贝初始化又会调用该拷贝构造函数本身, 如此无限循环, 永远也不会成功执行拷贝构造函数;
* 所以拷贝构造函数的第一个形参必须是引用类型

### 编译器可以绕过拷贝构造函数

在拷贝初始化过程中, 编译器可以优化代码, 跳过拷贝/移动构造函数, 直接创建对象

例如:

```c++
string null_book = "9-999-99999-9";	//拷贝初始化
```

* 例子中, 编译器可以不跳过拷贝/移动构造函数; 即使用临时量`"9-999-99999-9"`创建一个临时的`string`, 然后使用拷贝/移动构造函数将临时的`string`拷贝/移动到正在创建的`null_book`中

* 编译器也可以选择跳过拷贝/移动构造函数, 直接创建对象; 将上面的代码改写为

```c++
string null_book("9-999-99999-9");
```

## 1.2拷贝赋值运算符*

> 与类控制其对象如何初始化一样, 类也可以控制其对象如何赋值

### 重载运算符的简介

> 简要介绍一些重载运算符(**overloaded operator**), 更多见第14章

重载运算符本质上是一个函数, 其名字由`operator`后接表示要定义的运算符符号组成

* 如, 赋值运算符是一个名为`operator=`的函数

与其他普通函数一样, 运算符函数有返回类型和形参列表

* 形参表示运算符的操作数

一些运算符必须被定义为成员函数, 如赋值运算符; 

* 作为成员函数的运算符函数, 其左操作数与隐式`this`形参绑定, 其右操作数(如果有的话)作为显式实参传递

特别的, 拷贝赋值运算符是指右操作数的类型与左操作数相同时的赋值运算符; 

* 在定义类的拷贝赋值运算符时, 该运算符函数接受一个同类型的实参
* 为了与内置类型的赋值保持一致, 赋值运算符通常返回一个指向其左操作数的引用
  * 值得注意的是, 标准库要求保存在容器中的类型要具有赋值运算符, 且其返回值是左操作数的引用

### 合成拷贝赋值运算符

如果类未定义自己的拷贝赋值运算符, 编译器会为它合成一个;

合成拷贝赋值运算符的行为

* 对于某些类, 合成拷贝赋值运算符用来禁止该类型对象的赋值
* 其他情况下, 合成拷贝赋值运算符将右操作数的每个非静态成员赋予左操作数的对应成员; 这一工作是通过成员类型的拷贝赋值运算符来完成. 返回一个指向左操作数的引用
  * 对于数组类型的成员, 逐个赋值数组元素

## 1.3析构函数*

析构函数(**destructor**), 释放对象所使用的资源和销毁对象的非静态成员, 以及做一些相关所需的工作

* 析构函数是类的特殊的成员函数
  * 名字由`~`加类名组成, 没有返回值, 也不接受形参
  * 有函数体和析构部分
  * 形式: `~class_name()`
* 析构函数不能被重载, 因为没有形参

### 析构函数的工作

在析构函数中, 首先执行其函数体, 然后销毁成员; 成员按照初始化顺序的逆序销毁

* 在函数体中是在该对象销毁前希望执行的工作; 通常, 是释放该对象分配的所有资源

* 析构函数的销毁部分是隐式的, 如何销毁对象的成员取决于成员的类型
  * 内置类型: 直接销毁内置成员
    * 内置类型没有析构函数, 因此在销毁内置类型的成员之前什么也不需要做, 
  * 类类型: 通过执行类类型成员的析构函数来销毁该成员

### 何时调用析构函数

在一个类的对象被销毁时, 都会自动调用其析构函数, 包括:

* 变量在离开其作用域时被销毁
* 当一个对象被销毁时, 其成员被销毁
* 容器被销毁时其元素被消耗
* 当`delete`一个指向动态对象的指针时, 该动态对象被销毁
* 当整个表达式结束时, 其中被创建的临时对象被销毁

### 合成析构函数

当类没有定义析构函数时, 编译器为它合成一个;

合成析构函数(**the synthesized destructor**)

* 行为:
  * 对于某些类, 合成析构函数用来阻止该类型的对象被销毁
  * 其他情况下, 合成析构函数有一个空的函数体

## 1.4三五原则*

拷贝控制有五个操作: 

* 拷贝构造函数, 拷贝赋值运算符, 析构函数
* (C++11) 移动构造函数, 移动赋值运算符

C++语言并没有要求我们必须定义所有这些操作; 我们可以定义其中的零个或多个操作. 

* 三五原则:  **这些操作通常被看作一个整体; 一般情况下, 当类需要定义其中一个操作, 往往也需要定义其他所有操作**

确定一个类是否要定义自己的拷贝控制成员时的一些经验

* 如果类需要析构函数, 几乎可以确定它也需要拷贝构造函数和拷贝赋值运算符, 还有移动构造函数和移动赋值运算符
* 如果类需要拷贝构造函数, 几乎可以确定它也需要拷贝赋值运算符, 反之亦然
* 如果类需要移动构造函数, 几乎可以确定它也需要移动赋值运算符, 反之亦然

## 1.5使用`=default`(C++11)

可以使用`=default`显式地要求编译器生成拷贝控制成员的合成版本

* 在类的内部使用`=default`, 合成函数是隐式`inline`
* 在类外部的成员定义使用`=dfault`, 合成函数不是`inline`

注意: `=default`只能用于有合成版本的成员函数, 如拷贝控制成员, 默认构造函数

## 1.6阻止拷贝

对于某些类来说, 拷贝操作是没有合理的含义. 在这种情况下, 定义类时必须采用某种机制阻止拷贝或赋值. 例如, `iostream`类阻止了拷贝, 以避免多个对象写入或读取相同的IO缓冲

### 定义删除的函数(C++11)

在C++11下, 将拷贝构造函数和拷贝赋值运算符定义为删除的函数(**deleted function**), 能够阻止对象的拷贝.

* 形式: 在函数的形参列表后面加上`=delete`

  ```c++
  struct NoCopy {
      NoCopy() = default;
      NoCopy(const NoCopy&) = delete;
      NoCopy &operator=(const NoCopy&) = delete;
      ~NoCopy() = default;
  };
  ```

* `=delete`告诉编译器不要定义这些成员; 因此函数被声明为删除后, 程序中没有对应的实体, 也不能在程序中以任何方式使用它;
* 说明: 
  * 与`=default`不同, `=delete`只能出现在函数第一次声明的时候;
  * 与`=default`不同, 可以对任何函数指定`=delete`
  * 删除的析构函数
    * 对于一个删除了析构函数的类型, 编译器不允许定义该类型的变量或创建该类型的临时对象; 而且如果一个类有某个成员的类型删除了析构函数, 也不能定义该类型的变量或临时对象
    * 对于一个删除了析构函数的类型, 可以动态分配该类型的对象, 但是不能释放这些对象

### 合成成员函数可能是删除的

如果一个类有数据成员不能默认构造, 拷贝, 赋值或销毁, 则对应的合成成员函数被定义为删除

具体为

* 类的合成析构函数被定义为删除的情况
  * 某个成员自己的析构函数是删除的或不可访问的
* 类的合成拷贝构造函数被定义为删除的情况
  * 某个成员的拷贝构造函数是删除的或不可访问的
  * 某个成员的析构函数是删除的或不可访问的
* 类的合成拷贝赋值运算符被定义为删除的情况
  * 某个成员的拷贝赋值运算符是删除的或不可访问的
  * 该类有一个`const`或引用成员
* 类的合成默认构造函数被定义为删除的情况
  * 某个成员自己的析构函数是删除的或不可访问的
  * 某个成员自己的默认构造函数是删除的或不可访问的, 且该成员没有类内初始符
  * 该类有一个引用成员, 该成员没有类内初始符
  * 该类有一个`const`成员, 该成员的类型没有显式地定义默认构造函数且没有类内初始符

### `private`拷贝控制

C++11之前的阻止拷贝的方法

* 声明并且定义`private`的拷贝构造函数和拷贝赋值运算符
  * 用户不能访问`private`成员, 但友元和成员可以访问, 此时友元和成员可以进行拷贝
* 声明但不定义`private`的拷贝构造函数
  * 除了s15.2.1 p594的例外, 声明但不定义一个成员函数是合法的; 而所有试图使用一个未定义的成员将导致一个链接时错误
  * 因此, 这样做的话可以预先阻止任何拷贝该类型对象的企图
    * 试图拷贝对象的用户代码将在编译阶段被标记为错误
    * 成员函数或友元函数中的拷贝操作将会导致链接时错误

# 2.拷贝控制和资源管理*

通常, 管理在类外资源的类必须定义拷贝控制成员; 这种类需要通过析构函数来释放对象所分配的资源, 而需要析构函数的类也几乎肯定需要自己的拷贝构造函数和拷贝赋值运算符

在定义这些函数之前, 我们首先确定此类型对象的拷贝语义; 一般来说, 有两种选择

* 拷贝操作使类的行为像一个值; 例如, 标准库容器和`string`
  * 像值的类都有自己的状态; 当拷贝一个像值的对象时, 副本对象和原对象是完全独立的; 改变副本不会对原对象有任何影响, 反之亦然
* 拷贝操作使类的行为像一个指针; 例如, `shared_ptr`
  * 像指针的类共享状态; 当拷贝一个像指针的对象时, 副本对象和原对象使用相同的底层数据; 改变副本会改变原对象, 反之亦然

为了说明这两种方式, 以`HasPtr`类为例子, 为`HasPtr`定义拷贝控制成员. 首先, 令其的行为像一个值; 然后重新实现`HasPtr`类使其的行为像一个指针

* `HasPtr`类有两个成员, 一个`int`类型变量`i`和一个指向`string`的指针`ps`

### 2.1像值的类Classes that ack like values*

为了提供类值(**valuelike**)的行为, 对于类管理的资源, 每个对象都应该拥有一份自己的拷贝;

* 因此, 每个`HasPtr`对象必须都有一份`ps`指向的`string`的拷贝.
  * 拷贝构造函数中要拷贝`string`对象, 而不是拷贝指针
  * 析构函数中要释放`string`对象
  * 拷贝赋值运算符中, 释放当前已有的`string`对象, 拷贝右操作数中的`string`对象

```c++
class HasPtr {
public:
    HasPtr(const std::string &s = std::string):
    	ps(new std::string(s)), i(0) { }
    HasPtr(const HasPtr &p):
    	ps(new std::string(*p.ps), i(p.i) { }
	HasPtr& operator=(const HasPtr &);
    ~HasPtr() {delete ps;}
private:
    std::string *ps;
    int	i;
};
           
HasPtr& operator=(const HasPtr &rhs)
{
    auto newp = new string(*rhs.ps);
    delete ps;
    ps = newp;
    i = rhs.i;
    return *this;
}
```

编写拷贝赋值运算符的代码时, 要确保一个对象赋予它自身时也能正确操作; 如果可能, 编写的运算符应该是异常安全的----当异常发生时能将左操作数置于一个有意义的状态

* 在本例中, 通过先拷贝右操作数, 使得拷贝赋值运算符可以处理自赋值情况, 并能保证在异常发生时代码是安全的

### 2.2像指针的类Classes that ack like pointers*

为了提供类指针的行为, 类的拷贝构造函数和拷贝赋值运算符应该拷贝指针成员本身, 而不是它指向的资源

* 令一个类的行为类似于指针的最好方法是使用`shared_ptr`来管理类中的资源;
* 如果希望直接管理资源, 使用引用计数是不错的选择

### 引用计数

引用计数的工作方式如下

* 除了初始化对象外, 每个构造函数(拷贝构造函数除外)还要创建一个引用计数, 用来记录右多少对象与正在创建的对象共享状态. 当创建一个对象时, 只有一个对象共享状态, 因此将计数器初始化为1
* 拷贝构造函数不分配新的计数器, 而是拷贝给定对象的数据成员, 包括计数器. 拷贝构造函数递增共享的计数器, 表示给定对象的状态又被一个新用户所共享
* 析构函数递减计数器, 表示共享状态的用户少了一个. 如果计数器变为0, 则析构函数释放状态

* 拷贝赋值运算符递增右操作数的计数器, 递减左操作数的计数器. 如果左操作数的计数器为0 , 拷贝赋值运算符就必须销毁状态

在哪里存放引用计数

* 其中一种方式是, 将计数器保存在动态内存中

### 定义一个使用引用计数的类

```c++
class HasPtr {
public:
    HasPtr(const std::string &s = std::string) :
    	ps(new std::string(s)), i(0), use(new std::size_t(1)){ }
    HasPtr(const HasPtr &p) :
    	ps(p.ps), i(p.i), use(p.use) { ++*use; }
    HasPtr &operator=(cosnt HasPtr&);
  	~HasPtr();
private:
    std::string sp;
    int i;
    std::size_t *use;
};

HasPtr::~HasPtr()
{
    if (--*use == 0) {
        delete ps;
        delete ust;
	}	
}

HasPtr &operator=(const HasPtr& rhs)
{
    ++*rhs.use;
    if (--*use == 0) {
        delete ps;
        delete use;
    }
    ps = rhs.ps;
    i = rhs.i;
    use = rhs.use;
    return *this;
}
```

# 3.交换Swap*

除了定义拷贝控制成员时, 管理资源的类通常定义一个名为`swap`的函数

* 对于打算用于重排元素顺序的算法的类, 定义`swap`十分重要; 
* 这类算法在需要交换元素时会调用`swap`函数; 如果类有自己的`swap`函数, 算法将使用类自定义的版本; 如果没有则使用标准库中的`swap`函数

为了交换两个对象, 需要进行一次拷贝和两次赋值; 如下是类值`HasPtr`

```c++
HasPtr temp = v1;
v1 = v2;
v2 = temp;
```

* 例子中, `v1`中的`string`对象被拷贝两次: 一次是将`v1`拷贝初始化`temp`, 一次是赋值运算符将`temp`赋予`v2`
* 将`v2`赋予`v1`的语句拷贝了一次原来`v2`中的`string`

理论上, 上面例子中的内存分配都是不必要的; 我们更希望`swap`交换指针; 如下

```c++
string *temp = v1.ps;
v1.ps = v2.ps;
v2.ps = temp;
```

### 编写自己的`swap`函数

```c++
class HasPtr {
    friend void swap(HasPtr&, HasPtr&);
    // other member as before
};
inline
void swap(HasPtr &lhs, HasPtr &rhs)
{
    using std::swap;
    swap(lhs.ps, rhs.ps);
    swap(lhs.i, rhs.i);
}
```

### 在`swap`函数中调用`swap`, 而不是`std::swap`

在`swap`函数中调用`swap`, 而不是`std::swap`, 而且使用`using`声明标准库的`swap`: `using std::swap`

* 在函数匹配中, (如果有的话)类型特定的`swap`是优于标准库中的`swap`;
* 使用`using std::swap`后, 名字`swap`可以指向标准库的`swap`函数

* 因此, 在函数匹配时
  * 如果存在类型特定的`swap`, 那么类型特定的`swap`是最佳匹配
  * 如果不存在类型特定的`swap`, 那么标准库的`swap`是最佳匹配

### 在赋值运算符中使用`swap`

定义`swap`的类通常使用`swap`来定义它们的赋值运算符, 使用一种名为拷贝并交换(**copy and swap**)的技术

* 具体为: 将左操作数与右操作数的拷贝交换

  ```c++
  HasPtr& HasPtr::operator=(HasPtr rhs)
  {
      swap(*this, rhs);
      return *this;
  }
  ```
  * 例子中, 右操作数被值传递到形参`rhs`中, 因此`rhs`是右操作数的拷贝; 然后将左操作数`*this`和右操作数的拷贝`rhs`交换

* 拷贝并交换这一技术的有趣之处是, 它自动处理了自赋值情况并且也是异常安全的
  * 在改变左操作数之前拷贝右操作数, 这保证了自赋值的正确;
  * 代码唯一可能抛出异常的是拷贝右操作数时的拷贝构造函数中的`new`表达式; 它在改变左操作数之前才可能发生

# 4.拷贝控制的示例(p519)

# 5.管理动态内存的类(p524)

# 6.移动对象(C++11)

在某些情况下, 对象拷贝后就立即被销毁; 此时, 移动而非拷贝对象会大幅度提升性能

* 标准库容器, `stirng`和`shared_ptr`类都支持移动操作和拷贝操作
* IO和`unique_ptr`类支持移动操作, 不支持拷贝操作

## 6.1右值引用(C++11)

为了支持移动操作, C++11引入一种新的引用类型, 右值引用(**rvalue reference**);

右值引用, 是必须绑定到右值的引用, 通过`&&`来获得右值引用

* 右值引用只能绑定到一个将要销毁的对象; 因此, 能无顾虑地将右值引用的资源"移动"到其他对象

左值与右值是表达式的属性; 有些表达式生成或需要左值, 而另外一些生成或需要右值

* 左值, 表示的是一个对象的身份; 右值, 表示的是一个对象的值
* 左值有持续的状态; 右值有短暂的状态, 要么是字面常量, 要么是表达式求值过程中的临时对象

为了与右值引用区分开来, 将常规引用称为左值引用(**lvalue reference**)

* 非`const`左值引用能够绑定左值, 但不能绑定到一个右值上
* 右值引用能够绑定右值, 但不能绑定到一个左值上
* `const`左值引用能够绑定左值和右值

### 变量是左值

其实, 变量是一个没有运算符而有一个运算符对象的表达式; 

变量表达式是左值表达式, 毕竟变量能够存在直至离开其作用域.

### 标准库`move`函数(C++11)

虽然不能将一个右值引用直接绑定到一个左值上, 但我们可以显式地将一个左值转换为对应的右值引用类型

标准库`move`函数, 定义在`utility`头文件中

* 接受一个实参, 无论是左值还是右值; 返回一个与实参绑定的右值引用
* 说明: 
  * 调用`move`告诉编译器将一个实参像右值那样处理, 无论是左值还是右值
  * 对于调用中的实参, 在调用`move`后我们可以销毁它, 也可以赋予它新值(如果是左值的话), 但是不能使用原本的值, 不能对原本的值做任何假设
  * 使用该函数时, 不提供`using`声明, 直接调用`std::move`

## 6.2移动构造和移动赋值(C++11)

类似`string`类, 如果自定义的类也同时支持移动和拷贝, 那么也能从中受益.

为了支持移动操作, 需要为其定义移动构造函数和移动赋值运算符.

移动构造函数(**move constructor**)

* 第一个形参必须是指向该类类型的右值引用, 其他形参必须有默认实参

* 移动构造函数要确保移后源对象(**moved-from object**)在移动操作后是有效的, 且是可安全析构的

  * 移后源对象, 即该函数中第一给个形参指向的对象; 在移动操作中, 将移后源对象中的资源移动到其他对象中

* 例子

  ```c++
  StrVec::StrVec(StrVec &&s) noexcept
      : elements(s.elements), first_free(s.first_free), cap(s.cap)
  {
  	s.elements = s.first_free = s.cap = nullptr;
  }
  ```

  * `noexcpet`, 表示该构造函数不抛出任何异常
  * 例子中, 正在创建的对象接管了给定的`StrVec`中的内存; 然后, 将给定的`StrVec`中的指针都置为`nullptr`, 使得给定对象处于能够安全地销毁的状态

### 移动操作, 标准库和异常

移动操作通常不分配任何资源, 因此通常不会抛出异常. 当编写一个不抛出异常的移动操作时, 应该将此事通知标准库.

* 原因: 除非标准库知道我们的移动构造函数不会抛出异常, 否则它会认为移动对象时可能会抛出异常, 并且为了处理这种可能性而做一些额外的工作

一种通知标准库的方法是, 在构造函数中指明`noexcept`

* `noexcept`是C++11引入的, 用于承诺一个函数不抛出异常(见s18.1.4 p779)
* 使用方法: 在函数的形参列表后指定`noexcept`
  * 在构造函数中, `noexcept`出现在形参列表和初始化列表开始的冒号`:`之间, 而且必须在声明和定义中都指定`noexcept`

为什么在移动构造函数中需要`noexcept`

* 有两个事实
  * 一是, 移动操作虽然通常不抛出异常, 但是允许抛出异常
  * 二是, 标准库容器需要对异常发生时其自身的行为提供保障
* 假设将对象`A`的资源移动到对象`B`中, 对象`A`的资源已经部分被移动至对象`B`, 如果此时发生异常, 无论对象`A`还是对象`B`都处于不完全的状态, 而且都被部分修改, 无法保证异常安全
* 因此, 如果不通知标准库移动构造函数不会抛出异常, 标准库会认为移动构造函数可能抛出异常; 然后为了保证异常安全, 不选择使用移动构造函数而使用拷贝构造函数

### 移动赋值运算符

移动赋值运算符, 执行析构函数和移动构造函数的工作

* 如果移动赋值运算符不抛出任何异常, 应该将其标记为`noexcept`
* 移动赋值运算符必须正确处理自赋值

```c++
StrVec &StrVec::operator=(StrVec &&rhs) noexcept
{
    if (this != &rhs) {
        free();
        elements = rhs.elements;
        first_free = rhs.first_free;
        cap = rhs.cap;
        rhs.elements = rhs.first_free = rhs.cap = nullptr;
    }
    return *this;
}
```

### 合成的移动操作

如果类没有定义任何一个拷贝控制成员, 而且每个非静态成员都是可移动的, 编译器将为它合成移动构造函数或移动赋值运算符

* 内置类型的成员是可移动的
* 类类型的成员需要对应的移动操作: 移动构造函数或移动赋值运算符

移动操作不会隐式地定义为删除; 如果我们显式地使用`=default`要求编译器合成移动操作, 但编译器不能移动所有成员, 则编译器会将移动操作定义为删除; 将合成的移动操作定义为删除的函数的情况: 

* 移动构造函数被定义为删除
  * 类成员定义了拷贝构造函数, 但未定义移动构造函数
  * 类成员未定义拷贝构造函数且编译器不能为其合成移动构造函数
  * 类成员的移动构造函数被定义为删除的或是不可访问的
  * 类的析构函数被定义为删除的或是不可访问的
* 移动赋值运算符被定义为删除
  * 类成员定义了拷贝赋值运算符, 但但未定义移动赋值运算符
  * 类成员未定义拷贝赋值运算符且编译器不能为其合成移动赋值运算符
  * 类成员的移动赋值运算符被定义为删除的或是不可访问的
  * 类成员是`const`或引用

如果类定义了移动构造函数或/和移动赋值运算符, 则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的.

### 移动操作与函数匹配

当一个类有移动构造函数和拷贝构造函数时, 编译器使用普通的函数匹配来确定使用哪个构造函数; 赋值操作的情况类似.

* 对于左值实参, 由于左值不能隐式地与右值引用绑定, 所以移动操作都不是可行函数, 所以最佳匹配是拷贝操作 
* 对于右值实参, 右值与右值引用是精确匹配, 右值与`const`左值引用需要转换, 所以最佳匹配是移动操作

### Copy-and-Swap赋值运算符和移动

以`HasPtr`为例

```c++
class HasPtr {
public:
    //added move constructor
    HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i) { p.ps = 0; }
    //assignment operator is both the move- and copy-assignment operator
    HasPtr& HasPtr::operator=(HasPtr rhs) { swap(*this, rhs); return *this;}
    // other member as before
};

```

* 在`HasPtr`中添加了一个移动构造函数; 此时`HasPtr`的赋值运算符既是拷贝赋值运算符, 也是移动运算符
* 因为, 赋值运算符中的形参被拷贝初始化; 而拷贝初始化根据实参的类型来选择使用拷贝构造函数或移动构造函数

### 移动迭代器适配器(C++11)

移动迭代器(**move adaptor**)适配器: 

* 移动迭代器适配一个给定迭代器, 改变其解引用运算符的引用

* 操作
  * 其解引用运算符返回一个右值引用
  * 其他操作不变

`make_move_iterator`函数

* 作用: 接受一个迭代器, 返回一个移动迭代器

可以在迭代器算法中使用移动迭代器

* 不过, 标准库不保证哪些算法适用移动迭代器, 哪些不使用. 
* 只有在确信算法在为一个元素赋值(或将其传递给一个用户定义的函数)后不再访问它时, 才能将移动迭代器传递给算法

```c++
auto last = uninitialized_copy(make_move_iterator(begin()), 
                               make_move_iterator(end()),
                               first);
```

## 6.3右值引用和成员函数

> 除了构造函数和赋值运算符外, 如果一个成员函数提供拷贝和移动版本, 它也能从中得到性能提升

通常使用与拷贝/移动构造函数和赋值运算符相同的形参模式

* 拷贝版本接受一个`const`左值引用
* 移动版本接受一个非`const`右值引用

* 形式: 

  ```c++
  //X是类型
  void mem_func(const X&);
  void mem_func(X&&);
  ```

  * 只有非`const`右值实参才会使用第二个版本; 其他能转换成`X`类型的实参使用第一个版本

* 说明
  * 通常不需要为函数操作定义接受一个`const X&&`或一个普通`X&`形参的版本
    * 当我们希望从实参中移动数据时, 通常传递一个右值引用, 因为通常需要修改实参的状态所以不能是`const`
    * 从一个对象进行拷贝的操作不应该改变对象, 因此通常不使用普通`X&`作为形参

## 右值/左值引用成员函数(C++11)

通常, 不管一个对象是左值还是右值, 我们都可以在该对象上调用成员函数

```c++
string s1 = "a value", s2 = "another";
auto n = (s1 + s2).find('a');
s1 + s2 = "wow!";
```

* 例子中, `s1 + s2`表达式返回一个右值; 可以在右值上调用`find`成员函数, 还可以对其赋值

C++11之前, 没有办法阻止这种使用方式; 而且为了向后兼容, 新标准库仍然允许向右值赋值; C++11标准中, 可以为`this`指向的对象指定左值或右值

* 用法: 成员函数的形参列表后放置一个引用限定符(**reference qualifier**): `&`和`&&`
  * `&`表示`this`指向左值, `&&`表示`this`指向右值
  * 与`const`限定符类似, 引用限定符只能用于非静态成员函数, 且必须同时出现在函数的声明和定义中
* 作用: 
  * 被`&`限定的成员函数只能用于左值对像, 被`&&`限定的成员函数只能用于右值对象

* 其他
  * 可以同时使用`const`和引用限定; 此时, 引用限定符必须跟在`const`后面
  * 可以基于引用限定进行函数重载;

* 例子

  ```c++
  class Foo{
  public:
      Foo &operator=(const Foo&) &;
      Foo someMen() const &;
  };
  ```