# 总结

动态内存

* `new`和`delete`运算符

* 智能指针: `shared_ptr`, `unique_ptr`, `weak_ptr`
* `allocator`类

[toc]

# 1.动态内存与智能指针

C++允许动态分配, 在程序运行时分配对象

* 动态内存的管理是通过一对运算符`new`和`delete`来完成
  * `new`: 在动态内存(堆)中分配, 也可以初始化, 对象; 返回一个指向该对象的指针
  * `delete`: 接受一个指向动态对象的指针, 然后销毁该对象, 释放对应的内存
* 正确地管理动态内存是非常棘手的; 特别是, 在稍微复杂的系统中就很难保证在正确时间释放内存

对象都有寿命(**lifetime**)

* 一些对象的寿命与在哪里创建有关, 有严格定义的寿命, 由编译器自动创建和销毁
  * 全局对象在程序启动时分配, 在程序结束时销毁; 
  * 局部自动对象在进入其定义所在的块时创建, 在离开块时销毁
  * 局部静态对象在第一次使用前分配, 在程序结束时销毁

* 动态分配(**dynamically allocated**)的对象的寿命与在哪里创建无, 只有显式释放才会销毁; 由程序来控制它的创建和销毁


内存按保存的对象分类

* 静态内存(**static memory**): 用来保存局部静态对象, 类的静态成员以及定义在任何函数之外的变量

* 栈内存(**stack memory**): 用来保存定义在函数内的非静态对象
* 堆内存(**heap memory**)/自由空间(**free store**): 用来保存动态分配的对象

C++11标准库提供了两种智能指针(**smart pointer**)模板类来管理动态对象, 定义在`memory`头文件中

* 智能指针的行为与常规指针类似, 重要的区别是智能指针可以自动销毁所指向的对象和释放对应的动态内存

* `shared_ptr`类型: 允许多个指针指向同一对象
* `unique_ptr`类型: 独占所指向的对象
* 标准库还定义一个伴随类`weak_ptr`:  一种弱引用, 指向`shared_ptr`所管理的对象

## 1.1`shared_ptr`类(C++11)*

`shared_ptr`与`unique_ptr`的共有操作; 

| 操作                                 | 描述                                             |
| ------------------------------------ | ------------------------------------------------ |
| `shared_ptr<T> sp;`, `unique<T> up;` | 指向`T`类型对象的空智能指针                      |
| `p`转换成`bool`                      | 如果`p`指向一个对象, 转换为`true`, 否则为`false` |
| `*p`                                 | 解引用; 返回`p`所指的对象                        |
| `p->mem`                             | 等于`(*p).mem`                                   |
| `p.get()`                            | 返回在`p`中保存的指针;                           |
| `swap(p, q)`, `p.swap(q)`            | 交换`p`和`q`中的指针                             |

`shared_ptr`专用的操作

| 操作                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `make_shared<T>(args)` | 返回一个`shared_prt`; 所指的对象是类型`T`, 使用`args`初始化  |
| `shared_ptr<T> p(q)`   | `p`是`shared_ptr`对象`q`的拷贝, 递增`q`中的引用计数; `q`中的指针必须能转换成`T*` |
| `p = q`                | `p`和`q`是`shared_ptr`对象, 所保存的指针必须能相互转换; 递增`q`的引用计数, 递减`p`的引用计数 |
| `p.unique()`           | 返回`true`, 如果`p.use_count()`为1; 其他情况, 返回`false`    |
| `p.use_count()`        | 返回与`p`共享对象的智能指针数量. 可能很慢, 主要用于调试.     |

具体说明

`make_shared<T>(args)`: 最安全的分配和使用动态内存的方式; 模板函数

* 该函数分配和初始化对象于动态内存, 返回一个指向该对象的`shared_ptr`
  * 该对象的类型是`T`, 根据`args`进行初始化

### 引用计数

每个`shared_ptr`都会记录其所管理的对象被多少个`shared_ptr`指向着; 通常将这个`shared_ptr`的数量称为引用计数(**reference count**).

* 拷贝一个`shared_ptr`, 其引用计数递增; 属于这种情况有: 
  * 函数的值传递和值返回
  * 作为赋值的右操作数
  * 拷贝初始化
* 销毁一个`shared_ptr`, 其引用计数递减; 属于这种情况有:
  * 作为赋值的左操作数; 是指原来的(赋值前的)`shared_ptr`的计数递减
  * 局部对象离去其作用域

当一个`shared_ptr`的引用计数变为0, 该`shared_ptr`自动销毁所指向的对象和释放该对象使用的内存

* 这是通过析构函数(**destructor**)完成销毁工作的; 析构函数控制此类型的对象销毁时的行为
* 在`shared_ptr`的析构函数中递减引用计数; 如果计数为0, 销毁所指向的对象和释放该对象使用的内存

注意: 

* 引用计数并不一定是一个计数器; 如何实现引用计数是由标准库的具体实现来决定

### 类与动态寿命的资源

> 动态寿命(**dynamic lifetime**), 是指动态分配的资源的寿命

程序使用动态内存的原因

* 不知道需要使用多少个对象; 例子: 容器类
* 不知道所需对象的准确类型;
* 需要在多个对象间共享数据

### 例子:`StrBlob`类(p455)

## 1.2直接管理动态内存

> 相对于智能指针, 使用`new`和`delete`管理内存非常容易出错

C++定义了两种用于分配和释放动态内存的运算符: `new`和`delete`

`new`运算符: 分配内存

* 分配给定类型的对象, 返回一个指向其分配的对象的指针

* 形式: 

  * 默认初始化: `new type_name`
  * 值初始化: `new type_name()`
  * 直接初始化: `new type_name(args)`
  * (C++11)列表初始化: `new type_name{a, b, c..}`
  * (C++11)`auto`推断: `new auto(obj)`
    * 从`obj`中推断出分配的对象的类型

  ```c++
  int *pi = new int;
  int *pi1 = new int();
  int *pi2 = new int(1024);
  const *pci = new const int(1024);
  vector<int> *pv = new vector<int>{0, 1, 2, 3};
  string *ps = new string;
  string *ps1 = new string();
  string *ps2 = new string(10, '9');
  auto p1 = new auto(obj);
  
  ```

* 如果分配一个`const`对象时, 一定要初始化

* 在堆上分配的对象是无名的, 因此`new`无法为其分配的对象命名

`delete`运算符: 释放由`new`分配的内存

* `delete`接受一个指针, 指向我们想要释放的对象; 销毁给定的指针指向的对象, 释放对应的内存
* 形式: `delete p`
  * `p`必须是指向动态分配的内存,  或者是一个空指针
* 说明
  * 如果`p`指向非动态分配的内存, 或者将相同的指针值释放多次, `delete p`的行为是未定义的
  * 编译器无法分辨一个指针指向的对象是动态分配的, 还是静态分配的, 也无法分辨一个指针所指的内存是否已经被释放

### 内存耗尽

当堆内存被耗尽(被用光), `new`无法分配对象; 在默认情况下, 如果`new`不能够分配所要求的内存空间, 它会抛出`bad_alloc`异常.

可以使用定位`new`(**placement new**)的形式来阻止`new`抛出异常, 如`new (nothrow) int`

* 更多见s19.1.2, p824
* 定位`new`表达式允许向`new`传递额外的参数, 来改变默认行为; 
  * 如例子中的`nothrow`, `nothrow`是在标准库中定义的对象;例子中的`new`表达式如果不能分配所需内存, 它不会抛出异常, 而是返回一个空指针

* 说明: `bad_alloc`和`nothrow`定义在`new`头文件中

### 内置指针管理动态内存

> 由前面可知, `new`和`delete`是通过内置指针来管理动态对象的;

由内置指针管理的动态对象, 直到被显式释放之前它都是存在的

当内置指针被销毁时什么都不会发生; 特别是, 当指针离开其作用域时, 它所指的对象什么都不会发生; 

* 如果该指针指向的是动态内存, 也不会自动释放该内存
* 更严重的是, 如果该指针是唯一一个指向某块动态内存的指针时, 没有其他方法来释放该内存, 除非结束程序

### 动态内存的管理非常容易出错

使用`new`和`delete`管理动态内存时的常见问题

* 忘记`delete`内存
  * 忘记释放动态内存, 也被称为内存泄漏(**memory leak**), 因为这种内存永远不可能被归还给自由空间. 
  * 检测内存泄漏错误是非常困难的, 通常直到内存耗尽时才会发现内存泄漏
* 使用已经被释放的对象
  * 在释放内存后将对应的指针置为空; 这样做的话有时可以检测出这种问题
* 同一块内存释放两次
  * 当有两个指针指向相同的动态对象时, 可能发生这种问题

## 1.3`shared_ptr`的其他操作*

其他定义和改变`shared_ptr`的方式

| 操作                     | 描述                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `shared_ptr<T> p(q)`     | 使`p`管理内置指针`q`指向的对象;`q`指向一个由`new`分配的内存且类型能转换为`T*` |
| `shared_ptr<T> p(u)`     | `u`是`unique_ptr`对象; `p`从`u`中接管对象的所有权, 并将`u`置为空 |
| `shared_ptr<T> p(q, d)`  | `p`从内置指针`q`中接管对象的所有权, 且`delete`运算符被代替为可调用对象`d` |
| `shared_ptr<T> p(p2, d)` | `p`是`shared_prt`对象`p2`的拷贝, 唯一区别是`p`的`delete`运算符被代替为可调用对象`d` |
| `p.reset()`              | 如果`p`是唯一指向其对象的`shared_ptr`, `reset`会释放`p`所指的对象; ... |
| `p.reset(q)`             | ...如果传递可选的参数内置指针`q`, 会令`p`指向`q`所指的对象, 否则将`p`置为空;... |
| `p.reset(q, d)`          | ...如果还传递了可调用对象`d`, `delete`运算符被代替为可调用对象`d` |

具体说明

`shared_ptr<T> p(q)`

* 对应的构造函数是`explicit`的; 因此

  * 不会有内置指针到`shared_ptr`的隐式转换
  * 不能使用复制初始化, 只能使用直接初始化

  ```c++
  shared_ptr<int> p1 = new int(1024);	//error
  shared_ptr<int> p2(new int(1024));	//ok
  ```

* `q`必须指向动态内存

`reset`操作

* 使得`p`不再指向当前的对象; 如果需要的话, 会释放`p`指向的对象

### 不要混合使用普通指针和智能指针

某个`shared_ptr`对象只与其自身的`shared_ptr`拷贝共同协调所指对象的析构

考虑下面将普通指针和智能指针混用的例子

```c++
void process(shared_ptr<int> ptr);	//process的声明
int *x(new int(1024));				//x是指向动态内存的普通指针
process(x);							//error: process不接受普通指针
process(shared_ptr<int>(x));		//合法,但x指向的指针被释放
int j = *x;							//未定义
```

* 例子中, 使用内置指针`x`显式地构造一个临时的`shared_ptr`对象传递给`process`函数;
* 当`process`函数调用完成后, 临时`shared_ptr`被销毁; 由于该临时`shared_ptr`的引用计数变为0, 析构函数释放临时`shared_ptr`指向的动态内存, 也就是`x`指向的动态内存
* 所以在`process`函数调用完成后, `x`指向的动态内存被释放; 之后试图使用`x`的行为都是未定义的

当将一个普通指针绑定到一个`shared_ptr`时, 我们将内存管理的任务交给了这个`shared_ptr`. 之后, 

* 不应该再使用内置指针来访问这个`shared_ptr`所指的内存
* 不应该使用**不属于该`shared_ptr`的`shared_ptr`拷贝**来访问这个`shared_ptr`所指的内存

## 1.4智能指针和异常*

使用异常处理的程序需要确保在异常发生后资源能够被正确地释放

* 一种简单的方法: 使用智能指针; 
  * 当退出函数时, 无论是正常退出还是发生异常导致退出, 局部对象都会被销毁; 
    * 作为局部对象的智能指针也会被销毁
  * 智能指针类能够确保在内存不再需要时将其释放, 即使程序块过早结束
* 使用`new`和`delete`管理内存: 
  * 在函数中, 如果在`new`和对应的`delete`之间发生异常而没有捕获该异常从而导致退出函数, 动态内存不会被释放, 造成内存泄漏 
  * 所以在函数中使用`new`和`delete`管理内存, 需要在函数中有相应的异常处理

智能指针和哑类(**Dumb class**)

* 许多C++类都定义了能够释放对象使用的资源的析构函数; 但并不是所有的类都是这样; 特别是那些为C和C++两种语言设计的类, 通常都要求用户显式地释放所使用的资源.
* 对于需要用户释放资源的类, 可以通过智能指针使用类的对象, 让智能指针负责管理对象的资源; 
  * 默认情况下, `shared_ptr`假定其指向动态内存; 如果智能指针管理的资源不是`new`分配的内存, 需要自定义一个函数代替默认的`delete`操作, 这个函数被称为删除器(**deleter**)函数;
  * 删除器的形参要求是`shared_ptr`中指针的类型`T*`

## 1.5`unique_ptr`类(C++11)

一个给定的对象只能被一个`unique_ptr`对象指向着; 当某个`unique_ptr`被销毁时, 它所指向的对象也会被销毁

`unique_ptr`的操作(其他操作在s12.1.1)

| 操作                    | 描述                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `unique_ptr<T> u1`      | 可以指向`T`类型对象的空`unique_ptr`; `u1`使用`delete`释放它的指针 |
| `unique_ptr<T, D> u2`   | 可以指向`T`类型对象的空`unique_ptr`; `u2`使用`D`类型可调用对象来释放它的指针 |
| `unique_ptr<T> u(q)`    | `unique_ptr`指向内置指针`q`所指的对象, `q`的类型必须能够转换成`T*` |
| `unique_ptr<T,D>u(q,d)` | `unique_ptr`指向内置指针`q`所指的对象; `u`使用`D`类型可调用对象`d`释放它的指针 |
| `u = nullptr`           | 释放`u`指向的对象, 使`u`置为空                               |
| `u.release()`           | 使`u`放弃对其保存的指针的控制, 返回该指针, 并将`u`置为空     |
| `u.reset()`             | 释放`u`指向的对象, 使`u`置为空                               |
| `u.reset(q)`            | 释放`u`指向的对象, 然后使`u`指向`q`所指的对象                |
| `u.reset(nullptr)`      | 释放`u`指向的对象, 使`u`置为空                               |

* `unique_ptr<T> u(q)`, `unique_ptr<T,D>u(q,d)`对应的构造函数是`explicit`的
* 除了一个例外情况, `unique_ptr`不支持拷贝和赋值
  * 例外: 可以拷贝或赋值一个将要被销毁的`unique_ptr`; 最常见的例子: 从函数中值返回一个`unique_ptr`

* 在`unique_prt`上重写一个删除器会影响到`unique_ptr`对象的类型以及如何构造(或`reset`该类型的对象

## 1.6`weak_ptr`类(C++11)

`weak_ptr`是不控制其所指对象寿命的智能指针

* `weak_ptr`只指向由`shared_ptr`管理的对象; 
* 将一个`weak_ptr`绑定到一个`shared_ptr`不会改变`shared_ptr`的引用计数; 
* 当最后一个指向对象的`shared_ptr`被销毁, 该对象也被释放, 即使有`weak_ptr`指向对象

`weak_ptr`的操作

| 操作                | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| `weak_ptr<T> w`     | 可以指向`T`类型对象的空`weak_ptr`                            |
| `weak_ptr<T> w(sp)` | 与`shared_ptr`对象`sp`指向相同对象的`weak_ptr`; `T`类型必须能转换为`sp`指向的类型 |
| `w = p`             | `p`可以是`weak_ptr`或者`shared_ptr`; 赋值后, `w`与`p`共享对象 |
| `w.reset()`         | 使`w`置为空                                                  |
| `w.use_count()`     | 与`w`共享对象的`shared_ptr`数目                              |
| `w.expired()`       | 如果`w.use_count()`为0, 返回`true`, 否则为`false`            |
| `w.lock()`          | 如果`w.expired()`为`true`, 返回一个空的`shared_ptr`, 否则返回一个指向共享对象的`shared_ptr` |

# 2.动态数组

C++语言和标准库分别提供了能够一次性分配一个对象数组的方法

* C++语言: 一种`new`表达式语法, 用来分配和初始化对象数组(**array of objects**)
* 标准库: `allocator`模板类, 允许我们将分配和初始化分开
  * `allocator`通常提供更好的性能和更灵活的内存管理能力

## 2.1分配和释放动态数组

### 分配动态数组

形式: `new T[size]`

* `size`指明要分配对象的数目; 类型必须是整型
* 如果分配成功, 返回指向第一个对象的指针
* 可以与类型别名结合使用, 此时可以省略`[size]`

```c++
int *pia = new int[get_size()];
typedef int arrT[42];
int *p = new arrT;
```

**初始化**动态分配对象的数组

* 默认情况下, 默认初始化`new`分配的对象: `new T[size];`
* 值初始化: `new T[size]();`
* (C++11)列表初始化: `new T[size]{a, b, c...}`
  * 如果初始符数量少于`size`, 后面剩余的对象被值初始化
  * 如果初始符数量多于`size`, `new`表达式失败且不会分配任何空间; 默认情况下, 抛出`bad_array_new_length`异常
* 不能在圆括号内提供初始符

**说明**

`new`不会分配一个数组类型的对象, 即使使用类型别名定义了一个数组类型

* 因此, 使用`new T[size]`分配动态内存时, 并不是得到一个`T[size]`数组类型的对象, 而是得到一组`T`类型对象, 有`size`个对象; 
* 类似的, 动态数组是指在堆上分配的一组对象, 不是一个数组类型的对象; 更是不能对所谓的"动态数组"调用`begin`或`end`, 或者对其使用范围`for`

* 

可以动态分配一个空数组, 如`new int[0]`

* 当使用`new`分配一个大小为0的数组时, `new`返回一个有效的非零指针
  * 返回的指针保证与`new`返回的其他任何指针都不相同, 类似于尾后指针或尾后迭代器
  * 返回的指针可以像使用尾后迭代器一样使用, 操作有: 比较, 递增递减, 指针算术; 注意, 不能解引用该指针

### 释放动态数组

形式: `delete [] pa`

* `pa`必须指向一个动态数组, 或为空指针
* `[]`是必要的, 表示`pa`指向动态数组的第一个元素; 如果忽略了`[]`, 行为是未定义的

```c++
typedef int arrT[42];
int *p = *arrT;
delete [] p;
```

`delete`按逆序销毁动态数组中的对象, 即最后一个对象首先被销毁, 然后是倒数第二个, 依此类推

### 管理动态数组的智能指针

标准库提供了一个可以管理`new`分配的动态数组的`unique_ptr`版本. 

下表是指向动态数组的`unique_ptr`中与普通`unique_ptr`不同的操作

| 操作                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `unique_ptr<T[]> u`    | `u`是空`unique_ptr`对象, 可以指向一个`T`类型的动态数组       |
| `unique_ptr<T[]> u(p)` | `u`指向`p`所指的动态数组;`p`是指向动态数组的内置指针, 其类型必须能转换为`T*`; |
| `u[i]`                 | 返回位置`i`的对象, 该对象在`u`所指的动态数组中; `u`必须指向某个动态数组 |

* 指向动态数组的`unique_ptr`不支持`.`和`->`成员访问运算符
* 在使用`unique_ptr`管理动态数组时, 必须在对象类型后面跟一对空方括号
* 指向动态数组的`unique_ptr`销毁其所管理的动态数组时, 自动使用`delete[]`

`shared_ptr`不直接支持管理动态数组; 

* 如果希望使用`shared_ptr`管理一个动态数组, 必须提供自己定义的删除器

  ```c++
  shared_ptr<int> sp(new int[10], [](int *p){delete[]p;});
  sp.reset();
  ```
  * 例子中使用一个lambda作为删除器

* 如果未提供删除器且将`shared_ptr`与动态数组绑定, 释放动态数组时将使用`delete`, 而不是`delete[]`, 所以此时释放动态数组的行为是未定义的

## 2.2`allocator`类

> 限制`new`的灵活性的一个方面是,`new`将内存分配和对象构造组合在一起; 
>
> 类似的, `delete`将对象析构和内存释放组合在一起

`allocator`模板类, 定义在`memory`头文件中, 允许我们将内存分配和对象构造分离开来

* 它提供了一种类型感知的内存分配方法, 所分配的内存是原始的, 未构造的
* 当一个`allocator`分配内存时, 它会根据给定的对象类型来确定恰当的内存大小并且对齐内存

| `allocator`的操作      | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `allocator<T> a`       | 定义一个名为`a`的`allocator`对象, 它可以为`T`类型对象分配内存 |
| `a.allocate(n)`        | 分配一段原始的未构造的内存; 该段内存能保存`n`个`T`类型对象   |
| `a.deallocate(p, n)`   | 从`T*`类型指针`p`中的地址开始, 释放保存了`n`个`T`类型对象的内存 |
| `a.construct(p, args)` | 在`T*`类型指针`p`所指的内存上使用实参`args`构造一个对象      |
| `a.destroy(p)`         | 执行`T*`类型指针`p`所指的对象的析构函数                      |

**表格说明**

`a.allocate(n)`

* 分配能保存`n`个`T`类型对象的原始内存; 返回一个对象, 表示分配的原始内存的开始位置

`a.deallocate(p, n)`

* `p`必须是之前从`allocate`函数返回的指针
* `n`必须是`p`创建时所要求的大小
* 在执行`deallocate`之前, 如果有对象的话, 用户必须对在这段内存上的任一对象执行`destroy`

`a.construct(p, args)`

* `p`必须是一个指向原始内存的`T*`类型指针
* `args`是零个或多个初始符; 如果`T`类型是类类型, 它们被传递给`T`类型中匹配的构造函数
* 早期版本: 只接受`p`和`T`类型的值

`a.destroy(p)`

* `p`必须是一个指向`T`类型对象的指针

**其他说明**

除了在`construct`中使用, 其他使用未构造的内存的行为是未定义的

### `allocator`算法

标准库定义了两个能够在原始内存中创建对象的算法, 定义在`memory`头文件

`unintialized_copy`算法

* `unintialized_copy(b, e, b2)`
  * 从迭代器`b`和`e`指示的输入范围中拷贝元素到迭代器`b2`指向的未构造的原始内存中
  * 返回一个前向迭代器, 指向本次构造中最后一个构造的对象的后面位置
  * `b2`所指的内存必须能够容纳输入序列中所有元素的拷贝
* `unintialized_copy(b, n, b2)`
  * 从迭代器`b`指向的元素开始, 拷贝`n`个元素到`b2`指向的未构造的原始内存中
  * 返回一个前向迭代器, 指向本次构造中最后一个对象的后面位置

`uninitialized_fill`算法

* `uninitialized_fill(b, e, t)`
  * 在迭代器`b`和`e`指示的原始内存范围中创建对象, 对象的值均为`t`
  * 返回一个前向迭代器, 指向本次构造中最后一个构造的对象的后面位置
* `uninitialized_fill(b, n, t)`
  * 从迭代器`b`指向的内存地址开始创建`n`个对象
  * 返回一个前向迭代器, 指向本次构造中最后一个构造的对象的后面位置
  * `n`是无符号类型
  * `b`必须指向足够大的未构造的原始内存, 能够容纳给定数量的对象

# 3.例子: 文本查询程序*(p484)



