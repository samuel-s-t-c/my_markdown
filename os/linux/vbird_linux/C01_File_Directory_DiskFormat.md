# 1. Linux的文件权限与目录配置

在Linux中, 每个文件对三种身份进行读写权限管理

* 拥有者(owner)
* 文件所属的用户组(group)
* 其他人(others)

## 1.1 用户与用户组

用户组

* 每个用户可以在多个用户组中

* root获得所有用户组的支持

其他人(others)

* 不是拥有者, 同时也不在文件所属的用户组中的用户

记录用户身份与用户组的文件

* 默认情况下, Linux将所有系统上的账号与一般身份用户, 和root的相关信息记录在`/etc/passwd`文件中
* 个人密码记录在`/etc/shadow`文件中
* 所有用户组的组名记录在`/etc/group`文件中

## 1.2 Linux文件权限

命令`ls`, 用于展示目录的内容; 使用`-l`选项, 将以长列表格式显示

* 单个文件的格式: `(文件权限) (链接数) (拥有者) (用户组) (文件容量) (最后修改日期) (文件名)`
* 在`(文件权限)`部分中有十个字符
  * 第一个字符用于代表该文件是目录, 文件或链接文件等
    * `d`: 目录
    * `-`: 一般文件
    * `l`: 链接
    * `b`: 块文件; 可按块随机读写的设备文件
    * `c`: 串行端口设备文件
  * 剩余的九个字符中, 以三个为一组, 分别表示owner, group和others的读写权限
    * 这三个字符按位置来表示权限; 以`rwx`顺序
    * `r`表示可读, `w`表示可写, `x`表示可执行, `-`表示没有对应的权限
* `(链接数)`部分表示有多少个文件名链接到此节点(inode)
  * inode是指文件系统中的inode
* `(文件容量)`部分表示容量的大小, 默认单位为Bytes

文件权限的重要性

* 系统保护: 关于系统服务的文件通常只有root才能读写或执行
* 团队开发软件或数据共享
* 未将权限设置妥当的危害

### 如何修改文件属性与权限

常用的命令

* `chgrp`: 修改文件所属用户组
* `chown`: 修改文件的拥有者
* `chmod`: 修改文件的权限, SUID, SGID, SBIT等的特性

`chmod`: 可以使用数字或符号来修改权限

* 使用数字来修改权限: 
  * `r`是4, `w`是2, `x`是1, `-`是0
  * 例子: `-rwxrwx---`的数字是`770`
* 使用符号来修改权限: `chmod MODE[,MODE]... FILE...`
  * `u`, `g`, `o`分别表示拥有者, 用户组和其他人; `a`表示全部身份
    * 默认为`a`
  * `+`表示加入, `-`表示移除, `=`表示设置
  * `r`, `w`,`x`分别表示写, 读, 执行三种权限
  * 例子: `chmod u=rwx,go=rx .bashrc`

### 文件权限的意义

对于常规文件来说, `rwx`权限是针对文件的数据的

* `r`(read): 可读取此文件的实际内容
* `w`(write): 可以编辑, 新增或是修改文件的内容(但不含删除该文件)
* `x`(execute): 系统可以执行该文件

目录, 也是文件, 只不过是记录文件名的列表; 那么对于目录来说, 

* `r`(read contents in directory): 可以读取目录结构列表
* `w`(modify contents in directory): 可以改动目录结构列表; 具体有
  * 建立新的文件与目录
  * 删除已经存在的文件与目录
  * 将已存在的文件或目录进行更名
  * 移动该目录内的文件, 目录位置
* `x`(access directory): 可以将目录作为工作目录, 即进入该目录

### 文件种类与扩展名

文件种类

* 常规文件(regular file): `-`
  * 纯文本文件, 二进制文件, 数据文件
* 目录: `d`
* 链接文件: `l`
* 设备文件:
  * 区块设备文件: `b`
  * 字符设备文件: `c`
* 套接字文件(socket): `s`
* 管道(FIFO, pipe): `p`

文件扩展名

* Linux的扩展名, 只是名字的一部分, 用来表示该文件是什么东西
  * 一个Linux文件能否被执行, 只与其文件属性有关
* 常用扩展名
  * `.sh`: 脚本或批处理文件
  * `Z`, `.tar`, `.tar.gz`, `.zip`, `.tgz`: 经过打包的压缩文件
  * `.html`, `.php`: 网页相关文件

Linux文件名

* 文件名长度: 文件系统ext2, ext3, ext4和xfs中, 单一文件或目录的最大容许文件名为255字节
* 文件名的字符: 由于Linux在命令行模式下的一些命令操作关系, 最好避免使用一些特殊字符
  * ``* ? > < ; & ! [ ] | \ ' " ` ( ) { }``

## 1.3 Linux目录配置

目录树(directory tree)

* 在Linux中, 所有文件与目录都是由根目录开始的, 然后一个一个的分支下来; 这样的目录配置, 被称为目录树
* 特性
  * 目录树的起始目录是根目录(`/`)
  * 每个目录不仅能使用本地分区的文件系统, 还能使用网络上的文件系统
  * 每个文件在此目录树中的文件名(包含完整路径)是独一无二的

### 1.3.1 FHS

文件系统层次结构标准(FHS, Filesystem Hierarchy Standard)

* FHS规范了每个特定的目录下应该要放置什么数据
  * FHS项目组一直根据实践经验改进该标准;

FHS依据文件系统使用的频繁与是否允许用户随意修改, 将目录定义成四种交互的形态; 下表给出一些示例目录

|              | 可分享shareable                        | 不可分享unshareable                   |
| ------------ | -------------------------------------- | ------------------------------------- |
| 不变static   | /usr(软件存放处), /opt(第三方辅助软件) | /etc(配置文件), /boot(启动与内核文件) |
| 可变variable | /var/mail(用户邮箱)                    | /var/run(程序相关)                    |
* 可分享, 是指可以分享给其他系统挂载使用的目录; 不可分享, 则是指不适合分享给其他主机的数据
* 不变, 是指不经常变动的数据; 而可变, 是指经常修改的数据

FHS仅对目录树架构定义了三层目录下面应该放置什么数据, 分别是

* `/`(根目录): 与启动系统有关
* `/usr`(unix software resource): 与软件安装/执行有关
* `/var`(variable): 与系统运行过程有关

* 在其他子目录层级内, 开发者可以自行进行配置

#### 根目录

根目录是整个系统中最重要的一个目录

* 因为, 所有目录都是由根目录衍生出来, 同时根目录也与启动, 还原, 系统修复等操作有关
* FHS标准建议: 根目录所在分区应该越小越好, 且应用程序所安装的软件最好不要与根目录放在同一个分区内, 保持根目录越小越好, 以减少根目录所在分区发生错误的机会

FHS要求根目录中必须有以下子目录的存在; 即使没有物理目录, 至少有链接目录

| 目录     | 应放置文件内容                                               |
| -------- | ------------------------------------------------------------ |
| `/bin`   | 在单人维护模式下还能够被使用的命令                           |
| `/boot`  | 启动时会使用到的文件, 包括Linux内核文件以及启动选项与启动所需配置文件 |
| `/dev`   | 任何设备与接口设备                                           |
| `/etc`   | 系统主要的配置文件; FHS建议不要放置可执行文件                |
|          | 必要: `/etc/opt/`, 放置第三方辅助软件`/opt`的相关配置文件    |
|          | 建议: `/etc/X11/`, 放置与X Window有关的配置文件; `/etc/sgml/`, 与SGML格式有关的配置文件; `/etc/xml/`, 与XML格式有关的配置文件 |
| `/lib`   | 启动时会用到的函数库, 以及在`/bin`或`/sbin`下面的命令会调用的函数库 |
|          | 必要: `/lib/modules/`, 放置可抽换式的内核相关模块(驱动程序)  |
| `/media` | 可删除的设备, 如DVD, 光盘等                                  |
| `/mnt`   | 暂时挂载的设备; 在没有`/media`的版本中, 用途与`/media`相同   |
| `/opt`   | 第三方辅助软件                                               |
| `/run`   | 系统启动所产生的信息; 早期FHS规定将其放置到`/var/run/`目录下 |
| `/sbin`  | 启动, 修复, 还原系统所需要的命令; 只有root才能够使用         |
|          | `/usr/sbin`, 放置服务器软件程序; `/usr/local/sbin`, 放置本机自行安装的软件所产生的系统执行文件 |
| `/srv`   | 网络服务所需要使用的数据; 如WWW服务器需要的网页数据可以放置到`/srv/www`中 |
|          | 若系统的服务数据尚未要提供给任何人浏览时, 放置到`/var/lib`中 |
| `/tmp`   | 一般用户或执行中的程序暂时放置文件的地方; FHS建议在启动时清除其中的数据 |
| `/usr`   | 见下一小节的表格                                             |
| `/var`   | 见下下小节的表格                                             |

FHS建议根目录中可以存在的目录

| 目录         | 应放置文件内容                                               |
| ------------ | ------------------------------------------------------------ |
| `/home`      | 系统默认的用户家目录(home directory)                         |
|              | `~`, 表示当前用户的家目录; `~USERNAME`, 表示USERNAME的家目录 |
| `/lib<qual>` | 与`/lib`不同格式的二进制函数库; 如`/lib64`中放置64位的函数库 |
| `/root`      | 系统管理员(root)的家目录                                     |

不在FHS标准中, 但非常重要的目录

| 目录          | 应放置文件内容                                               |
| ------------- | ------------------------------------------------------------ |
| `/lost+found` | 使用标准的ext2, ext3, ext4文件系统格式时才会产生的目录; 当文件系统发生错误时, 将一些遗失的片段放置到该目录下 |
| `/proc`       | 该目录本身是一个虚拟文件系统, 它放置的数据都是在内存中; 放置的数据有如系统内核, 进程信息, 外接设备的状态及网络状态等 |
| `/sys`        | 是一个虚拟文件系统; 记录内核与系统硬件信息相关的内容, 包括目前已加载的内核模块与内核检测到的硬件设备信息等 |

#### /usr目录

`/usr`

* `usr`是UNIX Software Resource的缩写; 也就是说, `/usr`中放置UNIX系统软件资源

* 根据FHS的基本定义, `/usr`里面放置的数据是可分享与不变的
* 由于所有系统默认的软件都会放置到`/usr`中, 因此该目录在系统安装完毕时占用最多的硬盘容量

FHS要求必须存在的目录

| 目录          | 应放置文件内容                                               |
| ------------- | ------------------------------------------------------------ |
| `/usr/bin`    | 所有一般用户能够使用的命令; FHS要求此目录下不应该有子目录. 由于功能与`/bin`类似, CentOS7将`/bin`链接到此目录 |
| `/usr/lib/`   | 与`/lib`功能相同; 因此, CentOS7将`/lib`链接到此目录          |
| `/usr/local/` | 系统管理员在本机安装非发行版默认提供的软件时, 建议安装到此目录 |
| `/usr/sbin/`  | 非系统正常运行所需要的系统命令; 由于与`/sbin`功能差不多, CentOS7将`/sbin`链接到此目录 |
| `/usr/share/` | 只读的数据文件, 包括共享文件                                 |
|               | 常见的子目录: `/usr/share/man`, `/usr/share/doc`, `/usr/share/zoneinfo` |

FHS建议存在的目录

| 目录              | 应放置文件内容                                               |
| ----------------- | ------------------------------------------------------------ |
| `/usr/games/`     | 与游戏比较相关的数据                                         |
| `/usr/include/`   | c/c++等程序语言的头文件与包含文件                            |
| `/usr/libexec/`   | 某些不被一般用户常用的执行文件或脚本                         |
| `/usr/lib<qual>/` | 与`/lib<qual>`功能相同; 因此, CentOS7将`/lib<qual>`链接到此目录 |
| `/usr/src/`       | 源代码                                                       |
|                   | 内核源代码建议放置到`/usr/src/Linux/`目录下                  |

#### /var目录

`/var`

* 主要针对经常性变动的文件, 包括缓存(cache), 日志文件(log file)以及某些软件运行所产生的文件
* 因此, 在系统运行后`/var`才会渐渐占用硬盘容量

FHS要求必须存在的目录

| 目录          | 应放置文件内容                                               |
| ------------- | ------------------------------------------------------------ |
| `/var/cache/` | 应用程序运行时会产生的缓存                                   |
| `/var/lib/`   | 程序本身执行时, 需要使用到的数据文件; 在此目录下, 各自软件应该有各自的目录 |
| `/var/lock/`  | lock文件;在CentOS7中, 此目录链接到`/run/lock/`               |
| `/var/log/`   | 日志文件                                                     |
| `/var/mail/`  | 个人电子邮箱; 在CentOS7中, 此目录链接到`/var/spool/mail`     |
| `/var/run/`   | 程序或服务启动后的PID; 在CentOS7中, 此目录链接到`/run`目录   |
| `/var/spool/` | 队列数据; 队列是指排队等待其他程序使用的数据                 |

### 1.3.2 绝对路径与相对路径

根据文件名写法的不同, 可以把路径(path)定义为

* 绝对路径: 由根目录(`/`)开始写起的文件名或目录名, 如`/home/samuel/.bashrc`
* 相对路径: 相对于目前路径的文件名写法; 开头不是`/`的路径就是相对路径, 如`./home/samuel`

# 2. Linux的文件与目录管理

## 2.1 目录与路径

特殊的目录

* `.`, `./`: 表示当前目录
* `..`, `../`: 表示上一层目录
* `-`: 表示前一个工作目录
* `~`: 表示当前用户的家目录
* `~USER`: 表示`USER`用户的家目录龙

关于目录的操作

| 命令    | 作用                       |
| ------- | -------------------------- |
| `cd`    | (bash内置命令)用于切换目录 |
| `pwd`   | 显示当前目录               |
| `mkdir` | 建立新目录                 |
| `rmdir` | 删除空目录                 |

环境变量`PATH`

* 在执行一个命令时, bash会去`PATH`定义的目录下查找可执行文件, 然后执行第一个查找到的可执行文件

## 2.2 文件与目录管理

| 命令     | 作用                         |
| -------- | ---------------------------- |
| `ls`     | 查看目录的内容               |
| `cp`     | 复制文件或目录               |
| `rm`     | 删除文件或目录               |
| `mv`     | 移动文件, 或者重命名单个文件 |
| `rename` | 重命名文件                   |
| `file`   | 查看文件类型                 |

一个文件的完整文件名由两部分组成

* 路径
* 基础名(basename), 即平常看到的"文件名"

## 2.3 查看文件内容

| 命令   | 作用                                       |
| ------ | ------------------------------------------ |
| `cat`  | (concatenate)由第一行开始显示文件内容      |
| `tac`  | 从最后一行开始显示文件内容                 |
| `nl`   | 带有行号显示文件内容                       |
| `more` | 每次显示文件内容的一页                     |
| `less` | 是`more`的进阶版                           |
| `head` | 显示文件内容的前几行                       |
| `tail` | 显示文件内容的后几行                       |
| `od`   | 以特定的格式查看(dump)文件; (默认为八进制) |

## 2.4 修改文件时间或创建新文件: touch

文件有三个主要的变动时间

* 修改时间(modification time, mtime): 最近变更文件内容的时间
* 状态时间(status time, ctime): 最近改变文件状态的时间
* 读取时间(access time, atime): 最近读取文件内容的时间

`touch`: 用于改变文件的时间戳(timestamp)

## 2.5 文件与目录的默认权限与隐藏权限

### 文件默认权限: umask

文件默认权限: 

* 是指一个用户在建立一个新文件或目录时的权限默认值
* 在默认权限上, 目录与普通文件是不一样的
  * 普通文件默认没有可执行权限, 即为`-rw-rw-rw-`
  * 目录默认默认有可执行权限, 即为`drwxrwxrwx`

命令`umask`: 用于查看与设置默认权限需要减掉的权限

* root的umask默认是0022
* 一般身份用户的umask默认是0002

### 文件隐藏属性

在Linux传统的ext2, ext3, ext4文件系统下, 

* `charttr`可以设置其他的系统隐藏权限
* `lsattr`可以查看文件的属性(包括隐藏属性)
* 其他文件系统可能无法完整支持以上命令

文件隐藏属性

* 见`man charttr`中的属性部分
* xfs文件系统仅支持`Aadis`属性

### 文件特殊权限

三种特殊权限:

* SUID, SGID, SBIT
* 使用`chmod`可修改以上特殊权限, 如`chmod 4755 filename`
  * SUID为4, SGID为2, SBIT为1

Set User ID, SUID

* 在文件拥有者的`x`权限位上
  * `s`: 表示SUID和拥有者的执行权限同时被设置
  * `S`: 表示SUID被设置, 而执行权限没有被设置
* 特性:
  * 仅对二进制程序有效
  * 执行者对于该程序需要具有`x`的可执行权限
  * 本权限仅在执行该程序的过程中有效
  * 执行者将具有该程序拥有者的权限

Set Group ID, SGID

* 在用户组的`x`权限位上
  * `s`: 表示SGID和用户组的执行权限同时被设置
  * `S`: 表示SGID被设置, 而执行权限没有被设置
* 对于文件的特性:
  * 执行者对于该程序需要具有`x`的可执行权限
  * 执行者在执行的过程中将会获得该程序用户组的支持
* 对于目录的特性:
  * 用户若对于此目录具有`r`与`x`的权限时, 该用户能够进入此目录
  * 用户在此目录下的有效用户组(efftive group)将会变成该目录的用户组
  * 若用户在此目录具有`w`的权限, 则用户所建立的新文件的用户组是此目录的用户组

Sticky Bit, SBIT

* 在其他人的`x`权限位上
  * `t`: 表示SBIT和执行权限同时被设置
  * `T`: 表示SBIT被设置, 而执行权限没有被设置

* 仅对目录有作用
  * 当用户对于此目录具有`w`和`x`权限时, 该用户具有写入的权限
  * 当用户在该目录下建立文件或目录时, 仅有自己与root才有权利看删除该文件

## 2.6 命令与文件的查找

| 命令      | 作用                                                    |
| --------- | ------------------------------------------------------- |
| `which`   | 在`PATH`的路径下查找命令; 注意: 不能查找shell的内置命令 |
| `type`    | (内置命令) 多种用途, 包括确定给定名字是否为命令         |
| `whereis` | 在一些特定的目录下查找文件                              |
| `locate`  | 用由`updatedb`准备的数据库查找文件名                    |
| `find`    | 在整个文件系统中查找文件                                |

# 3. Linux的磁盘与文件系统管理

## 3.1 文件系统

> 在磁盘分区完毕后,  还需要进行格式化(format), 这样操作系统才能够使用该磁盘; 而这个格式化, 就是对磁盘分区进行对应的文件系统格式设置

文件系统(filesystem)

* 是指在存储设备上组织文件的方式
* 通常可以将一个可被挂载的数据称为一个文件系统
* 种类
  * 索引式文件系统, 如ext
  * 链式文件系统, 如FAT
* 举例
  * Linux中, 最传统的磁盘文件系统是ext2; 之后有ext3, ext4. 最近有xfs系统
  * Windows98主要使用的文件系统是FAT; Windows2000以后的版本有NTFS系统

在索引式文件系统中, 通常有以下三种数据结构

* inode: 记录文件的权限与属性; 一个文件占用一个inode
* 数据区块(data block): 记录文件的实际数据; 若文件太大, 会占用多个数据区块

* 超级区块(superblock): 记录整个文件系统的整体信息, 包括inode与数据区块的总量, 使用量, 剩余量, 还有文件系统的格式与相关信息等
* 说明: 在对磁盘进行格式化时, 该类文件系统将indoe与区块都分配好了

### ext2文件系统

用于查看ext文件系统的命令

* `dumpe2fs`
* `blkid`

ext2文件系统的整体规划

* 文件系统最前面有一个启动扇区, 用于安装启动引导程序
* 而后是多个区块组(block group), 其中每个区块组有
  * 数据区块(data block): 用于放置文件数据; 区块大小可以是1K, 2K和4K;
    * 每个区块都有编号
    * 每个区块最多只能放置一个文件的数据; 若文件大于区块的大小, 则文件占用多个区块
  * inode表: 
    * 一个文件对应一个inode; 一个inode的大小均为128B(新的ext4与xfs可设置到256B)
    * inode记录的数据有
      * 文件的读写属性(rwx)
      * 文件的拥有者与用户组(owner, group)
      * 文件的大小(size)
      * 文件的建立或状态改变的时间(ctime)
      * 文件的最近读取时间(atime)
      * 文件的最近修改时间(mtime)
      * 定义文件特性的标识(flag), 如SUID
      * 文件的实际数据的指针(pointer): 使用多重间接
  * superblock: 记录整个文件系统相关信息, 大小一般为1024B; 在第一个区块组中必定有superblock, 在其他区块组中可能有备份的superblock; 主要信息有
    * 数据区块与inode的总量
    * 未使用与已使用的inode与数据区块的数量
    * 数据区块与inode的大小
    * 文件系统的挂载实际, 最近一次写入数据的实际, 最近一次检验磁盘(fsck)的时间等文件系统的相关信息
    * 一个有效位数值; 若该文件系统已被挂载, 则有效位为0, 否则为1
  * Filesystem Description(文件系统描述): 描述每个区块组的开始与结束的区块, 以及说明每个区块分别介于哪一个区块之间
  * 区块对照表(block bitmap): 记录每个区块号码是否使用
  * inode对照表(inode bitmap): 记录每个inode号码是否使用

#### ext2文件系统与目录树

每一个目录都有一个inode和(至少一个)数据区块; inode记录目录的权限与属性, 区块记录该目录下的文件名与其inode号
* 文件本身的inode中并不记录文件名, 只在目录的区块中记录其文件名

目录树的文件读取:

* 得到根目录的inode号: 系统可以通过挂载信息得到根目录的inode号
* 根据根目录的inode号得到inode的内容; 在确定用户的权限后, 得到根目录的区块内的文件名数据; 从中得到路径上的目录的inode号
* 然后再一层层地往下读取信息, 直至目的文件

目录树的文件创建: (文件写入的过程与其类似)

* 先确定用户对于欲新建文件的目录是否具有`w`与`x`的权限
* 根据inode对照表找到未使用的inode号, 并将新文件的权限和属性写入
* 根据区块对照表找到未使用的区块号, 并将实际的数据写入区块中, 且更新inode的区块指针数据
* 将刚刚写入的inode与区块数据同步更新inode对照表与区块对照表, 并更新超级区块的内容

### 日志式文件系统(如ext3,ext4,xfs)

> ext3/4文件系统支持带日志的文件写入

日志式文件系统(Journaling filesystem)

* 写入一个文件的过程:
  * 预备: 先在日志记录区块中记录某个文件准备要写入的信息
  * 实际写入: 先写入文件的权限与数据; 然后更新元数据
  * 结束: 在日志记录区中, 完成该文件的记录
* 若在写入文件时发生问题, 系统只要去检查日志记录区块, 就可以知道哪里发生问题, 并进行针对性的处理

### 其他Linux支持的文件系统

Linux常见的支持文件系统

* 传统文件系统: ext2, minix, FAT(用vfat模块), iso9660光盘
* 日志式文件系统: ext3, ext4, ReiserFS, Windows' NTFS, IBM's JFS, SGI's XFS, ZFS
* 网络文件系统: NFS, SMBFS

### XFS文件系统简介

xfs文件系统主要分为三个部分

* 数据区(data section): 与ext2类似, 包括inode, 数据区块, 超级区块等数据; 不过, inode与区块是动态配置的
* 活动登录区(log section): 用于记录文件系统的变化
* 实时运行区(realtime section)

命令`xfs_info`: 查看某个xfs文件系统的信息

### 其他

#### 文件系统的运行

当系统加载一个文件到内存后

* 若文件没有被修改过, 则在内存区段的文件数据会被设置为clean; 否则设置为dirty
* 系统会不定时地将内存中dirty的数据写回磁盘中

#### 挂载点mount point

将文件系统与目录树结合的操作, 被称为挂载; 而被挂载的目录, 被称为挂载点

* 挂载点, 即被挂载的目录, 是该文件系统的入口

#### VFS功能

Linux VFS(Virtual Filesystem Switch)

* Linux是通过一个名为VFS的内核功能区读取文件系统; 也就是说, Linux识别的文件系统是由VFS进行管理

#### 硬链接与软链接

硬链接(hard link, 实际链接)

* 背景知识: 文件名只与目录有关, 文件的实际内容与inode号有关
* 硬链接, 是指在某个目录下新增一条文件名链接到某个inode
  * 在同一个文件系统下才能进行硬链接
  * 不能硬链接目录
  * 当某个inode有多个硬链接时, 删除其中一个硬链接, 并不会影响其他硬链接

软链接(Symbolic link, 符号链接)

* 创建软链接, 会建立一个独立的链接文件; 该文件会让数据的读取指向源文件的文件名, 而不是inode
  * 当源文件被删除后, 软链接的文件将无法找到对应的源文件

## 3.2 文件系统的简单操作

| 命令 | 作用                                     |
| ---- | ---------------------------------------- |
| `df` | 文件系统的整体磁盘空间使用情况           |
| `du` | 某个文件集合的磁盘使用情况               |
| `ln` | 创建链接(默认创建硬链接, 也能创建软链接) |

## 3.3 关于磁盘的操作

常见关于磁盘的操作

* 查看磁盘的状态

* 分区
* 格式化
* 检验
* 挂载

| 命令         | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| `lsblk`      | 显示所有或指定磁盘的信息                                     |
| `blkid`      | 显示设备的属性                                               |
| `parted`     | 磁盘分区工具                                                 |
| `gdisk`      | 设置和创建分区表; 用于GPT分区                                |
| `fdisk`      | 设置和创建分区表; 用于MBR分区                                |
| `partprobe`  | 更新内核的分区表信息                                         |
| `mkfs`       | 一个综合命令, 会调用合适的命令以创建对应的文件系统(即磁盘格式化) |
|              | 有`mkfs.bfs`, `mkfs.ext2`, `mkfs.ext3`, `mkfs.ext4`, `mkfs.minix`, `mkfs.xfs`等 |
| `xfs_repair` | 修复xfs文件系统                                              |
| `fsck`       | 一个综合命令, 会调用合适的命令以检查和修复文件系统           |
| `mount`      | 挂载一个文件系统                                             |
|              | `mount -o remount,rw,auto`                                   |
| `umount`     | 卸载文件系统                                                 |
| `mknod`      | 创建块文件或字符文件; 在Linux内核2.6版后, 系统已经会自动地实时产生设备文件名 |
| `xfs_admin`  | 修改xfs文件系统的参数                                        |
| `tune2fs`    | 修改ext2/ext3/ext4文件系统的参数                             |

### 特殊设备loop挂载

若有光盘映像文件, 或使用文件作为磁盘时, 使用以下方法进行挂载

* `mount -o loop [dev] [dir]`

建立大文件以制作loop设备文件

* 建立大型文件: 使用`dd`建立给定大型的空文件
  * 建立一个512M的文件如, `dd if=/dev/zero of=/srv/loopdev bs=1M count=512`
* 格式化: 默认情况下不能够格式化文件, 要强制格式化
  * 如`mkfs.xfs -f /srv/loopdev`
* 挂载: 使用前面提到的`mount`来挂载
  * `mount -o loop /srv/loopdev /mnt`
* 开机挂载: 在`/etc/fstab`上添加相应的配置

## 3.4 设置开机挂载

本小节讨论如何让系统"自动"在启动时进行挂载

### 开机挂载: /etc/fstab及/etc/mtab

`/etc/fstab`文件: 是系统启动时的配置文件, 用于自动挂载文件系统

* 会按照文件中的顺序挂载文件系统

* 限制
  * 必须挂载根目录, 且必须先于其他挂载点进行挂载
  * 其他挂载点的要求: 已建立的目录, 遵守FHS
  * 所有挂载点在同一时间之内, 只能挂载一次
  * 所有硬盘分区在同一时间之内, 只能挂载一次
  * 若进行卸载, 工作目录不能在挂载点(及其子目录)之内

* 每一行的格式: `[设备/UUID等] [挂载点] [文件系统] [文件系统参数] [dump] [fsck]`
  * 每部分之间使用空格符作为分隔
  * `[设备/UUID等]`可以填写的数据主要有
    * 文件系统或磁盘的设备文件名, 如`/dev/sda1/`
    * 文件系统的UUID名称, 如`UUID=...`
    * 文件系统的LABEL名称, 如`LABEL=...`

`/etc/mtab`和`/proc/mounts`: 记录实际文件系统的挂载情况

## 3.5 创建swap分区

>  当物理内存不足时, 系统会将内存中的数据存放在swap分区中, 以腾出内存空间来运行其他程序

假设: 已经将系统建立起来,  但发现没有创建swap分区

解决方法:

* 使用物理分区创建swap分区
  1. 分区: `gdisk`
  2. 格式化: `mkswap`
  3. 使用: `swapon`
  4. 检查: `free`与`swapon -s`
* 使用文件创建swap文件
  1. 建立文件: `dd`
  2. 格式化: `mkswap`
  3. 使用: `swapon`

# 4. 文件与文件系统的压缩

* [rfc1952](https://www.ietf.org/rfc/rfc1952.txt)

## 4.1 压缩文件的用途与技术

在Linux中, 压缩文件有多种扩展名; 这些扩展名对应不同的压缩命令, 且不同命令所用的压缩技术并不相同

| 压缩命令   | 扩展名 |
| ---------- | ------ |
| `compress` | `.Z`   |
| `zip`      | `.zip` |
| `gzip`     | `.gz`  |
| `bzip2`    | `.bz2` |
| `xz`       | `.xz`  |

由于`bzip2`, `gz`及`xz`等命令仅能针对一个文件来压缩或解压缩, 常常使用将多个文件打包成一个文件

| 扩展名     | 说明                               |
| ---------- | ---------------------------------- |
| `.tar`     | 经`tar`打包后的文件, 并没有压缩过  |
| `.tar.gz`  | 经`tar`打包后, 由`gzip`压缩的文件  |
| `.tar.bz2` | 经`tar`打包后, 由`bzip2`压缩的文件 |
| `.tar.xz`  | 经`tar`打包后, 由`xz`压缩的文件    |

* 最初,  `tar`没有提供压缩的功能; 后来, 在GNU计划中, `tar`可以调用其他压缩命令, 将文件进行压缩

## 4.2 Linux常见的压缩命令

### gzip/gunzip, zcat/zmore/zless/zgrep

| 命令     | 说明                                                       |
| -------- | ---------------------------------------------------------- |
| `gzip`   | 压缩或解压缩文件                                           |
| `gunzip` | 解压缩文件                                                 |
| `zcat`   | 等于`gunzip -c`; 类似于`cat`, `zcat`能从压缩文件中读取字符 |
| `zmore`  | 类似于`more`                                               |
| `zless`  | 类似于`less`                                               |
| `zgrep`  | 类似于`grep`                                               |
| `egrep`  | 等于`zgrep -E`                                             |
| `fgrep`  | 等于`zgrep -F`                                             |
| `znew`   | 将`.Z`文件重新压缩成`.gz`压缩文件                          |

`gzip`

* 简介: 可解开`compress`, `zip`与`gzip`等格式的压缩文件; 提供`gzip`的压缩技术
  * `gzip`的出现是为了替换`compress`, 并提供更好的压缩比
* 格式: `gzip [-cdtv#] [name ...]`
  * `-c`: 将压缩后的数据输出到标准输入
  * `-d`: 进行解压缩
  * `-t`: 检查压缩文件的完整性(integrity)
  * `-v`: verbose; 显示每个文件的名字和压缩比
  * `-#`: `#`可以是[1-9]; 其中, 1是最快, 但压缩比最差, 9是最慢, 但压缩比最好

### bzip2, bzcat/bzmore/bzless/bzgrep

`bzip2`

* `bzip2`的出现是为了替换`gzip`, 并提供更好的压缩比
* 格式: `bzip2 [-cdkzv#] [name...]`
  * `-c`: 将压缩后的数据输出到标准输入
  * `-d`: 进行解压缩
  * `-k`: 保留原始文件
  * `-z`: 进行压缩(默认值)
  * `-v`: verbose; 显示每个文件的名字和压缩比等信息
  * `-#`: `#`可以是[1-9]; 其中, 1是最快, 但压缩比最差, 9是最慢, 但压缩比最好

其他命令

* 与上小节的命令大同小异

### xz, xzcat/xzmore/xzless/xzgrep

为了达到更高的压缩比, 得到了`xz`这个工具

`xz [-dtlkcv#] [name...]`

* `-c`: 将压缩后的数据输出到标准输入
* `-d`: 进行解压缩
* `-k`: 保留原始文件
* `-l`: 列出压缩文件的相关信息
* `-t`: 检查压缩文件的完整性
* `-#`: `#`可以是[1-9]; 其中, 1是最快, 但压缩比最差, 9是最慢, 但压缩比最好
* `-v`: verbose; 显示每个文件的名字和压缩比等信息

## 4.3 打包命令tar

> 打包命令, 能够将多个文件或目录包成一个大文件

`tar`

* 使用`tar`打包得到的文件, 被称为tarfile; 若将tarfile进行压缩, 此时压缩文件被称为tarball

```shell
tar [-z|-j|-J] [cv] [-f 待创建的新文件名] filename... #打包与压缩
tar [-z|-j|-J] [tv] [-f 已有的文件名]                #查看文件名
tar [-z|-j|-J] [xv] [-f 已有的文件名] [-C 目录名]     #解压缩  
```

* `-v`: verbose
* `-c`: 创建打包文件
* `-t`: 查看打包文件中有哪些文件名
* `-x`: 解压缩或解包, 可配合`-C`指定目录下进行操作
* `-z`: 通过gzip的支持来进行压缩/解压缩; 此时, 文件名的扩展命最好为`.tar.gz`
* `-j`: 通过bzip2的支持来进行压缩/解压缩; 此时, 文件名的扩展命最好为`.tar.bz2`
* `-J`: 通过xz的支持来进行压缩/解压缩; 此时, 文件名的扩展命最好为`.tar.xz`
* `-f filename`: 指定要处理的文件名
* `-p`: 保留备份数据的原本权限与属性
* `-P`: 保留绝对路径, 亦即允许备份数据中含有根目录存在
* `--exclude=FILE`: 在压缩的过程中, 不要将FILE打包

常用的形式

```shell
#压缩
tar -jcv -f {filename}.tar.bz2 {file...};
#查询
tar -jtv -f {filename}.tar.bz2;
#解压缩
tar -jxv -f {filename}.tar.bz2 [subfilename]-C {directory};
```

* 其中`-j`可换成`z`或`J`, 同时将文件名改为相应的扩展名

## 4.4 xfs文件系统的备份与还原

| 命令         | 作用                    |
| ------------ | ----------------------- |
| `xfsdump`    | xfs文件系统的增量备份   |
| `xfsrestore` | xfs文件系统图的增量还原 |

* 增量备份: 在上一次备份后, 只备份与上次不同(新增或修改)的文件
  * 在没有备份时, 只能进行完整备份
* 增量还原: 是指能够在增量备份中进行还原

`xfsdump`

* 限制:
  * 不支持没有挂载的文件系统备份, 即只能备份已挂载的文件系统
  * 必须使用root权限才能操作
  * 只能备份xfs文件系统
  * 备份下来的数据只能让`xfsrestore`解析
  * `xfsdump`是通过文件系统的UUID来辨别各备份文件, 因此不能备份两个具有相同UUID的文件系统
* 格式:
  * `xfsdump [-L S_label] [-M M_label] [-l #] [-f 备份文件] 待备份的文件系统`
  * `xfsdump -I`
* 选项说明
  * `-L`: xfsdump会记录每次备份的session标头, 这里添加对此文件系统的简易说明
  * `-M`: xfsdump可以记录存储媒介的标头, 这里添加对此媒介的简易说明
  * `-l`: 指定等级, 从0到9(默认为0, 表示完整备份; 其他数字为增量备份)
  * `-f`: 指定备份文件
  * `-I`: 从`/var/lib/xfsdump/inventory`列出目前备份的信息状态

`xfsrestore`

* 格式:
  * `xfsrestore -I`: 用来查看备份文件的相关信息
  * `xfstrestore [-f 备份文件] [-L S_label] [-s file] 待恢复目录`: 单一文件全系统恢复
  * `xfstrestore [-f 备份文件] -r 待恢复目录`: 通过增量备份文件来恢复系统
  * `xfstrestore [-f 备份文件] -i 待恢复目录`: 进入交互模式
* 选项:
  * `-I`: 查询备份文件的信息
  * `-f`: 指定备份文件
  * `-L`: xfsdump会记录每次备份的session标头, 这里添加对此文件系统的简易说明
  * `-s`: 表示仅恢复某特定的目录或文件
  * `-r`: 累积模式
  * `-i`: 交互模式

## 4.5 光盘写入工具

| 命令       | 作用                           |
| ---------- | ------------------------------ |
| `mkisofs`  | 创建iso9660/Joliet/HFS文件系统 |
| `cdrecord` | 向光盘写入数据                 |
| `wodim`    | 向光盘写入数据                 |
| `isoinfo`  | 查看镜像文件的信息             |

`mkisofs [-o 输出的镜像文件] [-Jrv] [-V vol] [-m file] 待备份文件...`

* `-o`: 指定想要产生的文件名
* `-J`: 产生交兼容Windows的文件名结构, 可增加文件名长度到64个unicode字符
* `-r`: 通过Rock Ridge产生支持UNIX/Linux的文件数据, 可记录较多数据(如UID/GID等)
* `-v`: verbose
* `-V vol`: 建立Volume
* `-m file`: 排除文件, 即指出不要备份到镜像文件的文件, 可使用*通配符
* `-graft-points`: 文件名允许使用graft point(嫁接点)

例子: 制作/修改可启动光盘镜像文件P279

* 得到系统安装的镜像文件
* 挂载该镜像文件, 然后将所有数据完整复制到某个目录中
* 修改数据: 需要kickstart的相关技术
* 制作可启动镜像文件: `mkdir -o  输出文件名 -b 启动引导程序 -c 启动的安全编录文件 -no-emul-boot -V 卷ID -boot-load-size 4 -R -J -v -T`

## 4.6 其他常见的压缩与备份工具

| 命令   | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| `dd`   | 转换并复制一个文件; 该命令按扇区去读写数据, 不会识别其中数据 |
| `cpio` | 从archives中复制文件, 或将文件复制到archives                 |

