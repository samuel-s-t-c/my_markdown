# 总结

* 枚举
* 模拟
* 递归, 分治
* 贪心
* 排序
* 前缀, 差分

* 二分
* 倍增

[toc]

# 枚举

思想

* 从某个集合中逐一判断是否满足要求

要点

* 解空间
  * 建立简介的数学模型
  * 注意: 可能的情况是什么? 需要枚举哪些要素
* 选择合适的枚举顺序
* 减少需要枚举的集合
  * 枚举的范围是什么

例子: 

* [熄灯问题](http://bailian.openjudge.cn/practice/2811/)
  * 视频:https://www.bilibili.com/video/av10046345/?p=4

# 模拟

思想

* 模拟问题中的操作

技巧: 

* 在写代码前, 确定好流程
* 尽量把每个部分模块化
* 调试时分块调试

习题:

* [生活大爆炸版石头剪刀布](https://uoj.ac/problem/15)
* [魔兽世界](http://bailian.openjudge.cn/practice/3750/)
* [猪国杀](https://loj.ac/problem/2885)

# 递归与分治

思想:

* 递归: 将问题分解为同类的子问题
* 分治: 将问题分解为两个或更多同类的子问题

## 递归

递归的两个重要特征:

* 结束条件

* 自我调用

* ```c
  int func(ARGS) {
      if (结束条件) return 最小子问题解;
      return func(缩小规模);
  }
  ```

递归优化

* 搜索优化
* 记忆化搜索

## 分治算法

大概流程

1. 分解: 父问题分解为两个或多个结构相同的子问题
2. 解决: 分解到某个容易求解的边界后, 进行递归求解
3. 合并: 将子问题的解合并为父问题的解

特征

* 问题的规模缩小到一定的程度就可以容易地解决
* 该问题可以分解为若干个规模较小的相同问题, 即该问题具有最优子结构性质, 利用该问题分解出的子问题的解可以合并为该问题的解
* 问题所分解出的各个子问题是相互独立的, 即子问题之间不包含公共的子问题
  * 如果各子问题是不独立的, 则分治法要重复地解公共的子问题, 也就做了许多不必要的工作. 此时虽然也可用分治法, 但一般用动态规划较好

例子: 

* 归并排序
* 后序遍历

## 区别

递归是一种编程技巧, 一种解决问题的思维方式; 分治算法很大程度上是基于递归的, 解决更具体问题的算法思想.

# 贪心

思想:

* 每一步动作选择局部最优的操作

适用范围

* 最优子结构的问题

常见的两种解法

* 排序解法:
  * 常见情况是: 输入为一个包含几个权值的数组, 通过某种排序然后遍历模拟计算的方法得到最优值
* 后悔解法
  * 思路是无论当前的选项是否最优都接受, 然后进行比较, 如果选择之后不是最优了, 则反悔, 舍弃掉这个选项; 否则, 正式接受. 如此往复

证明方法

* 反证法
* 归纳法

与动态规划的区别

* 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择, 不能回退. 动态规划则会保存以前的运算结果, 并根据以前的结果对当前进行选择, 有回退功能

# 排序

https://oi-wiki.org/basic/sort-intro/

# 前缀和&差分

> 前缀和是一种重要的预处理，能大大降低查询的时间复杂度

一维前缀和

二维前缀和

多维前缀和

* 通常计算方法: 基于DP计算

树上的前缀和

差分

树上差分

# 二分

思想

* 在一个有序的区间内, 通过考察中间元素确定所查找元素的位置

# 倍增

思想

* 二进制的性质: 使用尽可能少的数表示一个范围

例子:

* LCA
* RMQ的ST表