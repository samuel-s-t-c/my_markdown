# 简介

动态规划(Dynamic programming), 是一种通过把原问题分解为相对简单的子问题以求解复杂问题的方法

* 常常适用于有重叠子问题和最优子结构性质的问题
* 动态规划方法的耗时往往远少于朴素解法

最优子结构

* 问题的最优解能够由相关子问题的最优解组合而成
* 而且这些子问题可以独立求解

思想:

* 对于一个给定问题, 求解出其不同部分(即子问题), 然后根据子问题的解得出原问题的解 

# 基础

动态规划方法通常用于求解最优化问题(optimization problem), 得到一个最优解

1. 刻画一个最优解的结构特征
2. 递归地定义最优解的值
3. 计算最优解的值
4. 利用计算出的信息构造一个最优解

动态规划的实现方法

* 带备忘的自顶向下法: 按自然的递归形式编写过程, 但过程中保存每个子问题的解
* 自底向上法: 恰当定义子问题"规模"的概念, 使得任何子问题的求解都只依赖于"更小的"子问题的求解; 因此可以将子问题按规模排序, 按由小至大的顺序进行求解
* 说明: 两者都具有相同的渐近运行时间; 在某些特殊情况下有所差异
  * 自顶向下方法并未真正递归地考察所有可能的子问题, 而自底向上法会考察所有可能的子问题
  * 自底向上法没有频繁的递归函数调用开销, 所以时间复杂性函数通常具有更小的系数

思考一个动态规划问题时, 应该弄清所涉及的子问题及子问题之间的依赖关系; 而**子问题图**能够准确地表达这些信息

* 子问题图是一个有向图, 每个顶点唯一地对应一个子问题
  * 若子问题x的最优解依赖于子问题y的最优解, 则存在一条从x到y的有向边
* 子问题图可以看做自顶向下递归调用树的简化版

* 通常情况下, 动态规划算法的运行时间与子问题图的顶点和边的数量呈线性关系

## 何时使用动态规划

* 问题具有最优子结构性质, 且子问题是相互独立(independent)
* 问题空间必须足够小, 即问题具有重叠子问题性质
  * 与之相对, 分治法适用于求解递归的每一步都生成全新子问题的问题最优子结构

### 最优子结构

考察问题是否具有最优子结构性质; 其通用模式如下:

1. 证明问题最优解的第一个组成部分是做出一个选择; 而做出这次选择会产生一个或多个待解的子问题
2. 对于一个给定问题, 在其可能的第一步选择中, 你可以假定已知哪种选择会得到最优解
3. 给定可获得最优解的选择后, 确定这次选择会产生哪些子问题, 以及如何地最好地刻画子问题空间
   * 刻画子问题空间的一个经验是: 保持子问题空间尽可能简单, 只在必要时才扩展它
4. 还需要证明: 每个子问题的解, 在作为构成原问题最优解的组成部分的同时, 也是它本身的最优解
   * 反证法加上"剪切-粘贴"技术证明

对于不同的问题领域, 最优子结构的不同体现在两个方面

* 原问题的最优解中涉及多少个子问题
* 在确定最优解使用哪些子问题时, 需要考察多少种选择

可以用”子问题的总数“和”每个子问题需要考察多少种选择“这两个因素的乘积来粗略分析动态规划算法的运行时间

* 也可以使用子问题图

### 重叠子问题

重叠子问题性质

* 是指问题的递归算法会反复地求解相同的子问题, 而不是一直生成新的子问题
* 一般来讲, 不同子问题的总数是输入规模的多项式函数为好

# 背包DP

有N种物品和一个容量为V的背包; 第$i$件物品所需的容量是$C_i$, 价值是$W_i$, 最多有$M_i$件可用; 求解如何将物品装入背包, 使得空间总和不超过背包容量, 且价值总和最大.

* $F[i,v]$表示前$i$件物品恰好放入一个容量为v的背包可以获得的最大价值

* 0-1背包: `M_i`为1
* 完全背包: `M_i`为无穷
* 多重背包: 每种物品都有其`M_i`值