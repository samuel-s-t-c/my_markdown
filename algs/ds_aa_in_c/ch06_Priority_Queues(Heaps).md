# 总结



[toc]

# 1 优先队列/Priority Queue的模型

优先队列至少要支持的操作

* 插入操作: 在优先队列中插入元素
* 删除最小值: 找到优先队列中的最小元素, 然后从队列中移除, 返回该元素

# 2 简单实现

基于链表

* 一种实现
  * 插入操作: 插入到表头, 时间为$O(1)$
  * 删除最小值: 遍历链表以删除最小值, 时间为$O(N)$
* 另一种实现: 始终让表保持有序
  * 插入操作: 插入到合适的位置, 时间为$O(N)$
  * 删除最小值: 第一个元素就是最小值, 时间为$O(1)$

基于二叉查找树: 

* 插入操作: 插入到合适的位置, 平均时间为$O(\log_2 N)$
* 删除最小值: 平均时间为$O(\log_2 N)$

# 3 二叉堆/Binary Heaps

二叉堆, 有时简称为堆

* 通常, 堆的结构是一棵完全二叉树
* 二叉堆具有堆顺序的性质

完全二叉树(complete binary tree)

* 完全二叉树的性质
  * 除了底层外, 其他层都填满了节点
  * 底层上的元素从左到右填入
* 高度为$h$的完全二叉树有$2^h$到$2^{h+1}-1$个节点; 这意味着, 有$N$个节点的完全二叉树的高度是$\lfloor \log_2 N\rfloor$, 显然它是$O(\log_2 N)$
* 实现: 可以基于一个数组来实现
  * 根节点在位置1上
  * 对于在数组位置$i$上的元素, 它的左子节点在位置$2i$, 右子节点在位置$2i+1$, 父节点在位置$\lfloor i/2 \rfloor$

堆的顺序

* 在一个堆中, 对于每个节点$X$, 其父节点中的键值小于(或等于)$X$中的键值; 而根节点除外
  * 这是最小堆; 还有一种叫最大堆, 即把最大元素放在根节点上
* 为了实现优先队列, 为了能够快速找出最小元素, 这里把最小元素放在根节点上

## 基本堆操作

插入

* 采用上滤(percolate up)策略: 自底向上为要插入的元素X寻找合适的位置
  * 在底层找到可用的空节点(即最后一个元素后面的位置)
  * 若元素X放入空节点, 且不会破坏堆的顺序, 那么插入到该位置; 否则, 将父节点的元素下移到该位置, 空节点将上移到父节点的位置
  * 然后重复如此直至找到合适位置
* 注意: 若要插入的元素X比堆上的元素都小, 那么它将会被推到根节点; 这样的话, 在某一时刻, 需要检验的位置是根节点, 而根节点没有父节点的
  * 处理方法: 
    * 一是, 显式地测试该节点是否为根节点; 
    * 二是, 由于本实现基于数组, 而根节点在数组的位置1上, 可以在数组的位置0上放一个很小的值; 该值保证小于或等于堆中的任何值, 称之为哨兵sentinel
* 最坏情况下的运行时间: $O(\log_2 N)$
* (平均运行时间)实验证明: 执行一次插入平均需要2.607次比较, 因此将元素平均上移1.607次

删除最小值

* 由于最小值在根节点, 所以很容易找到最小值; 但是删除最小值后, 根节点是空的, 而最后一个元素需要移到合适的位置
* 采用下滤(percolate down)策略: 自顶向下为最后一个元素X寻找合适的位置
  * 根节点是一个空节点
  * 若最后一个元素X放入空节点, 且不会破坏堆的顺序, 那么插入到该位置
  * 否则, 将空节点的最小子节点上移到该位置, 空节点下移到该子节点的位置
  * 然后重复如此直至找到合适位置
* 最坏情况下的运行时间: $O(\log_2 N)$
* 平均运行时间: $O(\log_2 N)$; 因为多数情况下, 最后一个元素会下滤到它删除前所在的那一层(即堆的底层)

## 其他的堆操作

若查找操作很重要, 除堆之外, 还必须用到其他的数据结构(如散列表)

* 最小堆本身只包含很少的关于顺序(order)的信息; 除了对整个堆进行线性搜索, 没有办法找出任意特定的元素.

假设通过某种方法实现查找操作, 且最坏运行时间小于$O(\log_2 N)$, 那么容易实现以下操作:

* 降低元素的键值: $O(\log_2 N)$

* 增加元素的键值: $O(\log_2 N)$
* 删除某个元素: $O(\log_2 N)$; 等于将该元素的键值降低无限小, 使其变为最小元素, 然后执行删除最小元素操作
* 堆的构建: $O(N)$; 把N个元素作为输入, 并将它们放入空堆中;算法如下
  1. 以任意顺序放入完全二叉树中
  2. 从$N/2$开始到1, 为这些节点进行下滤操作

# 4 优先队列的应用

在第9章有优先队列如何有效地用于几个图论算法的实现中; 以下是其他方面的应用

## 选择问题

问题:

* 给定N个元素以及一个整数k, 找出第k大的元素
* 这N个元素的集可以是全序的(totally ordered)

算法6A: 为了方便说明, 假设找出第k小的元素

* 将N个元素读入数组, 然后对数组执行堆构建操作
* 最后, 执行k次删除最小值操作; 其中, 最后一次删除最小值操作返回的元素是第k小的元素
* 分析:
  * 堆构建的最坏情况下运行时间是$O(N)$, k次删除最小值操作的总运行时间是$O(k\log_2 N)$
  * 可得, 算法的总运行时间是$O(N+k\log_2 N)$
    * 若$k=O(N/\log_2 N)$, 则算法的运行时间取决于堆构建操作, 且为$O(N)$
    * 若$k$的值较大, 则运行时间为$O(k\log_2 N)$
    * 若$k=\lceil N/2 \rceil$, 则运行时间为$\Theta(N\log_2 N)$
* 说明: 
  * 若想找出第k大的元素, 需要构建一个最大堆, 而不是最小堆; 然后执行k次删除最大值操作
  * 在第7章说明的一种快速排序算法, 堆排序(heapsort), 是此算法的思路一样的

算法6B: 

* 使用算法1B的思路: 在任一时刻维持有k个最大元素的集合S
  * 在读取前k个元素后, 进行排序; 
  * 每当读取一个新元素, 都要与第k大的元素$S_k$进行比较; 注意: $S_k$在集合中是最小的元素
  * 若新元素比$S_k$大, 将其替代$S_k$, 然后重新排序
  * 当读取所有元素后, 集合S中的最小元素就是整个输入中第k大的元素
* 与算法1B不同的是: 算法1B中使用数组来实现集合S, 而本算法使用最小堆实现集合S
* 分析
  * 读取前k个元素, 使用堆构建操作: $O(k)$
  * 处理每个其余的元素时
    * 检测该元素是否进入集合S中: $O(1)$
    * 在必要时删除$S_k$并插入新元素: $O(\log_2 k)$
  * 可得, 总运行时间为$O(k+(N-k)\log_2 k) = O(N\log_2 k)$
    * 若$k=\lceil N/2 \rceil$(即中位数)时, 总运行时间是$\Theta(N\log_2 N)$

其他算法

* 在第7章中, 有一个$O(N)$平均时间的算法
* 在第10章中, 有一个$O(N)$最坏情况时间的算法, 虽然不现实但很精巧

## 事件模拟

背景:

* 排队问题: 假设在一个银行系统, 有k个柜员; 每个顾客到达银行后需要在排队等待某个柜员来处理业务
  * 顾客的到达情况由一个概率分布函数来控制, 柜员的处理业务时间也是如此
  * 想要知道: 一位顾客平均等待多久, 或者排队的队列可能有多长
* 对于某些概率分布和k的某些值, 可以精确地计算出来; 但是, 随着k的变大, 分析会显着变得困难. 
* 因此, 需要使用计算机模拟银行的运行

事件模拟: 

* 由事件处理组成

* 对于排队问题, 有两种事件: 顾客的到达和顾客的离开
* 使用概率分布函数以生成输入流; 输入流的每个元素由每个顾客的到达时间和服务时间组成, 并按到达时间排序. 注意: 由于模拟时不需要准确的时间, 使用单位时间量(称之为tick)来作为时间的单位

模拟的策略

* 基于时钟: 
  * 模拟开始时, 时钟为0tick; 每次让时钟增加一个tick, 并且检查是否有一个事件发生
  * 若有事件发生, 则处理事件并且收集统计分析的数据
  * 当输入流中没有顾客, 所有柜员都是空闲时, 结束模拟
  * 策略的问题: 它的运行时间取决于tick的数量, 而不是顾客数或事件数
* 基于事件:
  * 在每个阶段, 让时钟直接走到下一个事件时间
  * 若事件是"离开", 那么要搜索这位要离开的顾客的统计资料, 然后检查"等待"队列中使用还有其他的顾客在等待; 
    * 若有, 则为该顾客分配一个柜员, 进行一些统计处理, 计算该顾客的离开时间, 然后将该顾客的"顾客离开"事件加到待发生的事件集中
  * 若事件是"到达", 那么检查是否有空闲的柜员;
    * 若有, 则为该顾客分配一个柜员, 进行一些统计处理, 计算该顾客的离开时间, 然后将该顾客的"顾客离开"事件加到待发生的事件集中
    * 若没有, 则将该顾客放入"等待"队列中
  * "等待"队列可以实现为一个队列(queue); 而待发生的事件集可以实现为一个优先队列
  * 分析: 若有C个顾客(因此有2C个事件)和k个柜员
    * 计算和处理每个事件需要$O(\log_2 H)$, 其中$H=k+1$为堆的大小
    * 事件模拟的运行时间将会是$O(C\log_2 (k+1))$

# 5 d堆/d-Heaps

d堆是二叉堆的一般化

* 除了每个节点有d个子节点外, d堆与二叉堆是一样的
* 分析
  * 插入操作: $O(\log_dN)$
  * 删除最小值操作: $O(d\log_dN)$
    * 从d个子节点中找到最小值: 使用标准算法就需要$d-1$次比较
* 说明
  * 实践显示, 4-堆的性能优于二叉堆
  * 当优先队列太大, 不能全部放入主存中, d堆能够以类似B树的方式来工作

# 6 左式堆/Leftist Heaps

除了不能直接实现查找操作外, 上述的二叉堆实现的最明显的缺点是

* 将两个堆合成一个堆, 这是困难的操作; 这种操作叫做合并(merge)
* 有许多堆的实现的合并操作的运行时间为$O(\log_2 N)$; 其中有
  * 左式堆, 斜堆, 二项队列

左式堆

* 左式堆是一棵有堆序的二叉树


## 左式堆的性质

零路径长度(*null path length, NPL*)

* 对于任意节点X, $Npl(X)$是从节点X到一个没有两个子节点的节点的最短路径长
  * 特别的, $Npl(NULL)=-1$
* 可得: 
  * 对于有0或1个子节点的节点的NPL是0
  *  任意节点的NPL = 其子节点的最小NPL + 1

左式堆的性质

* 对于堆中的每个节点X, 其左子节点的NPL大于等于右子节点的NPL
  * 这导致左式堆倾向于加深左路径, 其右路径是相对短的
  * 沿着左式堆的右路径确实是堆中最短的路径
* 在右路径上有r个节点的左式堆必然至少有$2^r-1$个节点
  * 反之, 对于有n个节点的左式堆, 其右路径最多有$\lfloor \log_2(N+1)\rfloor$个节点

## 左式堆的操作

左式堆操作的思路是将所有工作放在右路径上进行

* 对于可能会破坏左式堆性质的操作, 要进行恢复该性质的工作

合并操作: 两个左式堆的合并

* 递归实现的过程: 
  * 如果有一个堆是空的, 则返回另一个堆
  * 否则, 比较它们的根节点; 然后**递归地**, 将较小根节点的堆的右子树**合并**到有较大根节点的堆中,  然后将合并后的堆作为较小根节点的堆的右子树, 按需交互根节点的左右子节点, 最后更新NPL
* 非递归实现的过程: 通过两次右路径的遍历
  * 第一次遍历: 通过合并两个堆的右路径建立一棵新树
    * 以有序的顺序放置两个堆的右路径上的所有节点, 它们的左子节点保持不变
  * 第二次遍历: 堆的构建
    * 通过交换子节点获得左式堆的性质
* 分析:
  * 运行时间是成正比于两个堆的右路径的总长, 因此合并两个左式堆的时间边界为$O(\log N)$

插入操作

* 是合并操作的特殊情形, 即一个只有一个节点的堆和另一个堆进行合并
* 分析: $O(\log N)$

删除最小值操作

* 过程: 删除根节点, 然后合并两个子树
* 分析: $O(\log N)$

堆的构建

* 几种实现
  1. 构建一个基于指针的二叉堆
* 分析: 可以达到$O(N)$

# 7 斜堆/Skew Heaps

斜堆, 是左式堆的自调节版本

* 是一棵堆序的二叉树
* 与左式堆不同的是, 没有对树的结构进行限制

分析

* 所有单次操作的最坏情况运行时间均为$O(N)$
* 任意$M$次连续操作的最坏情况的总运行时间为$O(M\log N)$, 因此每次操作的摊还时间为$O(\log N)$

合并操作

* 递归实现: 与左式堆的合并操作几乎相同, 除了一个例外
  * 除了右路径上的最大节点外, 对于斜堆的所有结点, 无条件地交换左右子节点
* 非递归实现: 与左式堆类似
  * 有序合并右路径, 然后, 除了右路径上的最后一个节点(即最大节点), 为右路径上的其他节点交换左右子节点

# 8 二项队列/Binomial Queues

* 插入操作的平均运行时间: $O(1)$
* 所有操作的最坏情况的运行时间: $O(\log_2N)$

## 二项队列结构

二项树 (binomial tree)

* 高度$k$上的二项树$B_k$, 是通过将一棵$B_{k-1}$附加到另一棵$B_{k-1}$的根节点上而构成; 因此
  * $B_k$由一个根节点和子树$B_0,B_1,...,B_{k-1}$组成
  * $B_k$有$2^k$个节点
  * 在高度$d$上的节点数量是二项式系数$k \choose d$, 也就是$C_k^d$

二项队列, 是具有堆序性质的二项树的集合

* 二项队列中的二项树具有堆序性质

* 在二项队列中每一个高度上至多存在一棵二项树
  * 特别的, 在高度0上的二项树只有一个节点
* 例子: 用二项队列表示一个大小为13的优先队列
  * 可以用$B_3, B_2, B_0$集合来表示这个优先队列
  * 上面的集合可以写成$1101$: 既以二进制表示了13, 也表示集合有$B_3, B_2, B_0$, 没有$B_1$

## 二项队列的操作

查找最小值

* 查找每个二项树的根节点, 最多有$\log_2 N$个不同的树, 因此运行时间为$O(\log_2 N)$

* 或者, 维护关于最小值的信息以$O(1)$执行该操作

合并操作

* 根据二项树的性质, 可以很容易地将两个高度相同的树$B_k$组成一个新的高度为$k+1$的二项树, 运行时间为$O(1)$
* 两个二项队列合并时, 将两个高度相同的二项树组成新的树, 不断如此直至每个高度最多只有一棵树
* 设$N$为两个二项队列的节点数之和, 则有$O(\log_2 N)$棵二项树, 合并操作的最坏情况运行时间为$O(\log_2 N)$
* 为了更高效, 在二项队列中的二项树需要按高度排序

插入操作

* 是合并操作的一个特殊情况
* 设不在被插入的二项队列中的最矮二项树为$B_i$, 插入操作的运行时间与$i+1$成正比
* 由于二项队列中的每棵树出现的概率均为$1/2$, 插入操作预期在两次树合并后终止, 因此, 平均运行时间为$O(1)$
* 分析指出, 对于一个初始为空的二项队列进行$N$次插入操作, 最坏情况下的总运行时间为$O(N)$

删除最小值操作

* 过程: 
  * 首先, 在基于二项队列的优先队列$H$中找到有最小值的二项树$B_k$; 将$B_k$移出$H$, 形成新的队列$H'$
  * 然后, 从$B_k$中移除最小值, 得到另一个新的队列$H''$, 即$B_k$的子树$B_0,B_1,...,B_{k-1}$
  * 最后, 合并两个队列$H'$和$H''$
* 分析: 整个操作需要$O(\log_2 N)$
  * 找到最小值和创建两个队列$H', H''$, 需要$O(\log_2 N)$时间
  * 合并两个队列, 需要$O(\log_2 N)$时间

## 实现

删除最小值操作的要求

* 快速找出所有子树的根节点: 需要树的标准表示方法(基于链表)
  * 每个节点的子节点存储在一个链表中, 然后节点中有一个指向第一个子节点的指针
* 能够容易地合并两棵树: 所有子树按照高度的大小来排序
  * 由于两棵树合并时, 其中的一棵树作为子树被加到另一棵树上, 因此子树应该由大到小排序
* 总结:
  * 在二项树中的每个节点包含数据, 第一个子节点和一个兄弟节点
  * 二项树中的子节点由大到小排序