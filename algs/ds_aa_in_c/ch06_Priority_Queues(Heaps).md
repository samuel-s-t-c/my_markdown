# 总结



[toc]

# 1 优先队列/Priority Queue的模型

优先队列至少要支持的操作

* 插入操作: 在优先队列中插入元素
* 删除最小值: 找到优先队列中的最小元素, 然后从队列中移除, 返回该元素

# 2 简单实现

基于链表

* 一种实现
  * 插入操作: 插入到表头, 时间为$O(1)$
  * 删除最小值: 遍历链表以删除最小值, 时间为$O(N)$
* 另一种实现: 始终让表保持有序
  * 插入操作: 插入到合适的位置, 时间为$O(N)$
  * 删除最小值: 第一个元素就是最小值, 时间为$O(1)$

基于二叉查找树: 

* 插入操作: 插入到合适的位置, 平均时间为$O(\log_2 N)$
* 删除最小值: 平均时间为$O(\log_2 N)$

# 3 二叉堆/Binary Heaps

二叉堆, 有时简称为堆

* 通常, 堆的结构是一棵完全二叉树
* 二叉堆具有堆顺序的性质

完全二叉树(complete binary tree)

* 完全二叉树的性质
  * 除了底层外, 其他层都填满了节点
  * 底层上的元素从左到右填入
* 高度为$h$的完全二叉树有$2^h$到$2^{h+1}-1$个节点; 这意味着, 有$N$个节点的完全二叉树的高度是$\lfloor \log_2 N\rfloor$, 显然它是$O(\log_2 N)$
* 实现: 可以基于一个数组来实现
  * 根节点在位置1上
  * 对于在数组位置$i$上的元素, 它的左子节点在位置$2i$, 右子节点在位置$2i+1$, 父节点在位置$\lfloor i/2 \rfloor$

堆的顺序

* 在一个堆中, 对于每个节点$X$, 其父节点中的键值小于(或等于)$X$中的键值; 而根节点除外
  * 这是最小堆; 还有一种叫最大堆, 即把最大元素放在根节点上
* 为了实现优先队列, 为了能够快速找出最小元素, 这里把最小元素放在根节点上

## 基本堆操作

插入

* 采用上滤(percolate up)策略: 自底向上为要插入的元素X寻找合适的位置
  * 在底层找到可用的空节点(即最后一个元素后面的位置)
  * 若元素X放入空节点, 且不会破坏堆的顺序, 那么插入到该位置; 否则, 将父节点的元素下移到该位置, 空节点将上移到父节点的位置
  * 然后重复如此直至找到合适位置
* 注意: 若要插入的元素X比堆上的元素都小, 那么它将会被推到根节点; 这样的话, 在某一时刻, 需要检验的位置是根节点, 而根节点没有父节点的
  * 处理方法: 
    * 一是, 显式地测试该节点是否为根节点; 
    * 二是, 由于本实现基于数组, 而根节点在数组的位置1上, 可以在数组的位置0上放一个很小的值; 该值保证小于或等于堆中的任何值, 称之为哨兵sentinel
* 最坏情况下的运行时间: $O(\log_2 N)$
* 实验证明: 执行一次插入平均需要2.607次比较, 因此将元素平均上移1.607次

删除最小值

* 由于最小值在根节点, 所以很容易找到最小值; 但是删除最小值后, 根节点是空的, 而最后一个元素需要移到合适的位置
* 采用下滤(percolate down)策略: 自顶向下为最后一个元素X寻找合适的位置
  * 根节点是一个空节点
  * 若最后一个元素X放入空节点, 且不会破坏堆的顺序, 那么插入到该位置
  * 否则, 将空节点的最小子节点上移到该位置, 空节点下移到该子节点的位置
  * 然后重复如此直至找到合适位置
* 最坏情况下的运行时间: $O(\log_2 N)$
* 平均运行时间: $O(\log_2 N)$; 因为多数情况下, 最后一个元素会下滤到它删除前所在的那一层(即堆的底层)

## 其他的堆操作

若查找操作很重要, 除堆之外, 还必须用到其他的数据结构(如散列表)

* 最小堆本身只包含很少的关于顺序(order)的信息; 除了对整个堆进行线性搜索, 没有办法找出任意特定的元素.

假设通过某种方法得知每个元素的位置(最坏运行时间小于$O(\log_2 N)$), 得知以下操作的最坏情况下的运行时间

* 降低元素的键值: $O(\log_2 N)$

* 增加元素的键值: $O(\log_2 N)$
* 删除某个元素: $O(\log_2 N)$; 等于将该元素的键值降低无限小, 使其变为最小元素, 然后执行删除最小元素操作
* 堆的构建: $O(N)$; 把N个元素作为输入, 并将它们放入空堆中;算法如下
  1. 以任意顺序放入完全二叉树中
  2. 从$N/2$开始到1, 为这些节点进行下滤操作

# 4 优先队列的应用

在第9章有优先队列如何有效地用于几个图论算法的实现中; 以下是其他方面的应用

## 选择问题

问题:

* 给定N个元素以及一个整数k, 找出第k大的元素
* 这N个元素的集可以是全序的(totally ordered)

算法6A: 为了方便说明, 假设找出第k小的元素

* 将N个元素读入数组, 然后对数组执行堆构建操作
* 最后, 执行k次删除最小值操作; 其中, 最后一次删除最小值操作返回的元素是第k小的元素
* 分析:
  * 堆构建的最坏情况下运行时间是$O(N)$, k次删除最小值操作的总运行时间是$O(k\log_2 N)$
  * 可得, 算法的总运行时间是$O(N+k\log_2 N)$
    * 若$k=O(N/\log_2 N)$, 则算法的运行时间取决于堆构建操作, 且为$O(N)$
    * 若$k$的值较大, 则运行时间为$O(k\log_2 N)$
    * 若$k=\lceil N/2 \rceil$, 则运行时间为$\Theta(N\log_2 N)$
* 说明: 
  * 若想找出第k大的元素, 需要构建一个最大堆, 而不是最小堆; 然后执行k次删除最大值操作
  * 在第7章说明的一种快速排序算法, 堆排序(heapsort), 是此算法的思路一样的

算法6B: 

* 使用算法1B的思路: 在任一时刻维持有k个最大元素的集合S
  * 在读取前k个元素后, 进行排序; 
  * 每当读取一个新元素, 都要与第k大的元素$S_k$进行比较; 注意: $S_k$在集合中是最小的元素
  * 若新元素比$S_k$大, 将其替代$S_k$, 然后重新排序
  * 当读取所有元素后, 集合S中的最小元素就是整个输入中第k大的元素
* 与算法1B不同的是: 算法1B中使用数组来实现集合S, 而本算法使用最小堆实现集合S
* 分析
  * 读取前k个元素, 使用堆构建操作: $O(k)$
  * 处理每个其余的元素时
    * 检测该元素是否进入集合S中: $O(1)$
    * 在必要时删除$S_k$并插入新元素: $O(\log_2 k)$
  * 可得, 总运行时间为$O(k+(N-k)\log_2 k) = O(N\log_2 k)$
    * 若$k=\lceil N/2 \rceil$(即中位数)时, 总运行时间是$\Theta(N\log_2 N)$

其他算法

* 在第7章中, 有一个$O(N)$平均时间的算法
* 在第10章中, 有一个$O(N)$最坏情况时间的算法, 虽然不现实但很精巧

## 事件模拟

背景:

* 排队问题: 假设在一个银行系统, 有k个柜员; 每个顾客到达银行后需要在排队等待某个柜员来处理业务
  * 顾客的到达情况由一个概率分布函数来控制, 柜员的处理业务时间也是如此
  * 想要知道: 一位顾客平均等待多久, 或者排队的队列可能有多长
* 对于某些概率分布和k的某些值, 可以精确地计算出来; 但是, 随着k的变大, 分析会显着变得困难. 
* 因此, 需要使用计算机模拟银行的运行

事件模拟: 

* 由事件处理组成

* 对于排队问题, 有两种事件: 顾客的到达和顾客的离开
* 使用概率分布函数以生成输入流; 输入流的每个元素由每个顾客的到达时间和服务时间组成, 并按到达时间排序. 注意: 由于模拟时不需要准确的时间, 使用单位时间量(称之为tick)来作为时间的单位

模拟的策略

* 基于时钟: 
  * 模拟开始时, 时钟为0tick; 每次让时钟增加一个tick, 并且检查是否有一个事件发生
  * 若有事件发生, 则处理事件并且收集统计分析的数据
  * 当输入流中没有顾客, 所有柜员都是空闲时, 结束模拟
  * 策略的问题: 它的运行时间取决于tick的数量, 而不是顾客数或事件数
* 基于事件:
  * 在每个阶段, 让时钟直接走到下一个事件时间
  * 若事件是"离开", 那么要搜索这位要离开的顾客的统计资料, 然后检查"等待"队列中使用还有其他的顾客在等待; 
    * 若有, 则为该顾客分配一个柜员, 进行一些统计处理, 计算该顾客的离开时间, 然后将该顾客的"顾客离开"事件加到待发生的事件集中
  * 若事件是"到达", 那么检查是否有空闲的柜员;
    * 若有, 则为该顾客分配一个柜员, 进行一些统计处理, 计算该顾客的离开时间, 然后将该顾客的"顾客离开"事件加到待发生的事件集中
    * 若没有, 则将该顾客放入"等待"队列中
  * "等待"队列可以实现为一个队列(queue); 而待发生的事件集可以实现为一个优先队列
  * 分析: 若有C个顾客(因此有2C个事件)和k个柜员
    * 计算和处理每个事件需要$O(\log_2 H)$, 其中$H=k+1$为堆的大小
    * 事件模拟的运行时间将会是$O(C\log_2 (k+1))$

# 5 d堆/d-Heaps

d堆是二叉堆的一般化

* 除了每个节点有d个子节点外, d堆与二叉堆是一样的
* 分析
  * 插入操作: $O(\log_dN)$
  * 删除最小值操作: $O(d\log_dN)$
    * 从d个子节点中找到最小值: 使用标准算法就需要$d-1$次比较
* 说明
  * 实践显示, 4-堆的性能优于二叉堆
  * 当优先队列太大, 不能全部放入主存中, d堆能够以类似B树的方式来工作

# 6 左式堆/Leftist Heaps

除了不能直接实现查找操作外, 上述的二叉堆实现的最明显的缺点是

* 将两个堆合成一个堆, 这是困难的操作; 这种操作叫做合并(merge)
* 有许多堆的实现的合并操作的运行时间为$O(\log_2 N)$; 其中有
  * 左式堆, 斜堆, 二项队列

左式堆

* 左式堆是一棵二叉树

* 具有堆顺序的性质

## 左式堆的性质

零路径长度(*null path length, NPL*)

* 对于任意节点X, $Npl(X)$是从节点X到一个没有两个子节点的节点的最短路径长
  * 特别的, $Npl(NULL)=-1$
* 可得: 
  * 对于有0或1个子节点的节点的NPL是0
  *  任意节点的NPL = 其子节点的最小NPL + 1

左式堆的性质

* 对于堆中的每个节点X, 其左子节点的NPL至少与右子节点的NPL一样大
  * 这导致左式堆倾向于加深左路径, 其右路径是相对短的
  * 沿着左式堆的右路径确实是堆中最短的路径
* 在右路径上有r个节点的左式堆必然至少有$2^r-1$个节点
  * 反之, 对于有n个节点的左式堆, 其右路径最多有$\lfloor \log_2(N+1)\rfloor$个节点

## 左式堆的操作

左式堆操作的思路是将所有工作放在右路径上进行

* 对于可能会破坏左式堆性质的操作, 要进行恢复该性质的工作

合并操作: 两个左式堆的合并

* 递归实现的过程: 
  * 如果有一个堆是空的, 则返回另一个堆; 不然, 比较它们的根节点
  * 然后, 将较小根节点的堆的右子树**递归合并**到有较大根节点的堆中

* 注意: 插入操作只是合并操作的特殊情形: 一个只有一个节点的堆和另一个堆进行合并

# 7 斜堆/Skew Heaps

# 8 二项队列/Binomial Queues