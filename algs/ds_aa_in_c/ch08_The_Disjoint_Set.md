# 总结

不相交集ADT, 又称并查集

[toc]

# 1. 等价关系

集合$S$定义了一种关系$R$

* 定义: 对于集合$S$中的每一对元素$(a,b)$, $a$与$b$要么有关系$R$, 要么没有关系$R$; 若$a$和$b$存在关系$R$, 亦可表示成$a\;R\;b$

等价关系(equivalence relation)是满足以下三个性质的关系$R$:

* 自反性Reflexive: 所有$\;a\in S$, 都有$a\;R\;a$
* 对称性Symmetric: 当且仅当$a\;R\;b$, 才有$b\;R\;a$
* 传递性Transitive: 若$a\;R\;b$且$b\;R\;c$, 则$a\;R\;c$
* 例子:
  * 整数的$\le$关系不是等价关系, $==$关系是等价关系
  * 电气连通性(electrical connectivity)是等阶关系

# 2. 动态等价性问题

常见问题: 

* 假设存在等价关系$\sim$, 对于集合中的任意$a$和$b$, 确定是否$a\sim b$

元素$a\in S$的等价类(equivalence class)

* 是指在集合$S$中所有与$a$有等价关系的元素集合, 是$S$的一个子集

* $S$的每个成员都出现在某一个等价类中; 因此, 要确定是否$a\sim b$, 只需验证$a$和$b$是否都在同一个等价类中

解决策略: 验证$a$和$b$是否都在同一个等价类中

* 最初有N个集合, 每个集合包含一个不同的元素; 这里的每个集合是不相交的(disjoint), 即$S_i\cap S_j=\varnothing$

* 两种操作
  * find(查找)操作: 给定某个元素, 返回它所在的集合(也就是等价类)
  * union(合并)操作: 给定两个集合, 合并两个集合

一种实现

* 在一个数组中保存每个元素的等价类名字, 使得find操作是$O(1)$
* 同一个等价类中的元素都在同一链表中, 并且记录每个等价类的大小; 在执行union操作时, 将较小集合的名字改为较大集合的名字, 使得$N-1$次union操作的运行世界是$O(N\log_2N)$

后面部分讲述另一种实现

# 3. 基本数据结构

使用一棵树表示一个集合

* 树的根节点可以表示(或记录)集合的名字
* 根据问题可得, 节点需要包含的信息是指向父节点的指针

操作:

* find操作: 通过指向父节点的指针向上寻找根节点
* union操作: 将一棵树成为另一棵树的子树

操作优化: heuristic(启发式方法)

* find操作: 路径压缩; 在执行find操作期间, 使得路径上节点中的指针从指向父节点改为指向树的根节点
* union操作: 基于大小或高度,  将一棵较小的树成为另一棵较大的树的子树
  * 基于高度的union, 也称为基于秩的union
* 注意:  同时使用路径压缩与基于高度的union
  * 路径压缩会改变树的高度; 而基于高度的union操作需要记录树的高度
  * 若要重新计算树的高度, 没有有效的办法实现
  * 若不重新计算树的高度, 此时树所存储的高度只是估计值; 但是发现效率与基于大小的union一样
* 分析
  * 使用上述两种union heuristic时, 设某个集合的大小为$N$, 其树的深度至多为$\log_2N$
    * 在不使用路径压缩的情况下, find操作为$O(\log_2N)$, union操作为$O(1)$; 因此, 一系列$M$次操作最多为$O(M\log_2N)$
    * 研究表示, 在所有合理的模型下, 一系列$M$次操作的平均运行时间为$O(M)$; 因为随机执行union操作时, 通常是将非常小(甚至只有一个元素)的集合与大集合进行合并
  * 使用路径压缩, 而不使用上述两种union heuristic时, 研究证明一系列$M$次操作最多需要$O(M\log_2N)$运行时间

# 4. 最坏情况分析p273

当同时使用路径压缩和union heuristic时, 该算法在最坏情况下几乎为线性

* 具体地说, 最坏情况下的运行时间为$\Theta(M\cdot\alpha(M,N)), M\ge N$
  * 其中的$\alpha(M,N)$是阿克曼函数(Ackermann's function)的逆函数
    * 简单地说, 阿克曼函数增长地很快, 而其逆函数增长地很慢
    * 这里的阿克曼函数定义为$\begin{split}
      &A(1,j)=2^j\;for\;j\ge1\\
      &A(i,1)=A(i-1,2)\;for\;i\ge2\\
      &A(i,j)=A(i-1,A(i,j-1))\;for\;i,j\ge2
      \end{split}$
  * 由此, $\alpha(M,N)=min\{i\ge1|A(i,\lfloor M/N\rfloor)>\log_2N\}$
  * 在实际使用中, $\alpha(M,N)\le4$

## 具体分析

结论: 一系列$M=\Omega(N)$次union\find操作的总运行时间为$O(M\log^*N)$

* $\log^*N$的定义: 对$N$取多次对数, 使得$N\le1$; 这里的取对数的次数就是$\log^*N$

假设: union操作是基于秩(rank)的, find使用路径压缩; union/find操作以任何顺序出现

引理: 当执行一系列union指令时, 某个秩为$r$的节点必定至少有$2^r$个后裔(包括它自己)

* 证明: 数学归纳法
  * $r=0$时只有一个节点, 显然成立
  * 假设引理对于秩为$0,1,2,...,r-1$时成立; 令$T$是秩为$r$且后裔最少的树, $X$是$T$的根节点; 假设$T$是$T_1$和$T_2$在union操作后得到的, 且$X$是$T_1$的根节点, $T_2$的秩$\le$ $T_1$的秩
    * 由于$T$是秩为$r$且后裔最少的树, 则$T_1$的秩$\le r-1$
    * 由于 $T_1$的秩$\le$ $T$的秩, $T_1$和$T_2$的秩只能是$r-1$
    * 根据假设, $T_1$和$T_2$的后裔至少有$2^{r-1}$个; 可得$T$的后裔至少有$2^r$个

引理: 秩为$r$的节点数最多为$\frac{N}{2^r}$

* 证明: 
  * 不使用路径压缩时, 每个秩为$r$的节点是某棵至少有$2^r$节点的子树的根节点; 而且在子树中的子节点不会有$r$秩, 因此所有秩为$r$的节点表示的子树是不相交的
  * 因此, 最多有$\frac{N}{2^r}$棵不相交的秩为$r$的子树, 秩为$r$的节点数最多为$\frac{N}{2^r}$

引理: 在union/find算法中的任一时刻, 从叶节点到根节点的路径上的节点的秩是单调递增