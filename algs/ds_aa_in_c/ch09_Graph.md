# 总结

讨论图论中几种常见问题

[toc]

# 1. 定义

* 图(graph): 是由顶点(vertex)和边(edge, arc)组成的, $G=(V,E)$
  * $V$表示图$G$中所有顶点的集合, $E$表示$V$中顶点间的所有边的集合
* 边: 是由一对顶点组成, $e = (v, w),\;where\;v,w\in V$
* 赋权边(weighted edge): 包含权重(weight)/成本(cost)的边
* 赋权图(weighted graph): 图的边都是赋权边
* 有向图(directed graph, digraph): 顶点对是有序的图
* 完全图(complete graph): 图中的每个顶点与其他所有顶点之间都有一条边
* 稠密图(dense graph): 边的数量接近于完全图
* 稀疏图(sparse graph): 边的数量远远少于完全图 
* 两个顶点邻接(adjacent): $(v,w)\in E$, 即两个顶点由一条边连接
  * 在无向图(undirected graph)中, 若有边$(v,w)$, 则有边$(w,v)$
* 图的路径(path): $(w_i,w_{i+1})\in E\;for\;1\le i\lt N$, 即一系列邻接的顶点
  * 这里允许路径从一个顶点$v$, 在该顶点$v$结束; 若这样的路径中没有边, 那么路径长为0
* 路径的长度(length)/无权路径长(unweighted path length): 路径中边的数量
* 赋权路径长(weighted path length): 路径中边的权重值之和
* 图的环(loop): 一条从一个顶点$v$到它自身的边, 即$(v,v)$
* 图的简单路径(simple path): 一条路径上的所有顶点是互异的, 除了第一个和最后一个顶点可以是相同的
* 有向图的基础图(underlying graph): 将其边移除方向后得到的无向图
* 有向图的圈(cycle): 一条至少长为1的路径, 且第一个顶点和最后一个顶点相同, $w_1=w_N$
  * 简单圈: 圈的路径是简单的
  * 无圈的有向图(directed acyclic graph, DAG)
* 无向图的连通性(connection): 在无向图中每一个顶点能够通过某一条路径到达其他任意顶点
* 有向图的强连通性(strong connection): 在有向图中每一个顶点能够通过某一条路径到达其他任意顶点;
  * 与无向图的连通性类似
* 有向图的弱连通性(weak connection): 其基础图的连通性

关于图的示例: 航空系统

* 每个机场是一个顶点, 直达航线是一条边
* 若两个机场之间有一条直达航线, 那么可以说两个顶点用一条边连接
* 直达航线所需的时间, 距离或飞行费用, 可以被边的权重表示
* 由此可见, 表示航空系统的图可以是有向图

## 图的表示

* 邻接矩阵(adjacency matrix): 使用一个二维数组
  * 边$(u,v)$: $A[u][v]=1$; 若不存在边, 则设为0
    * 若有权重, $A[u][v]$设为对应的权重值; 使用很大或很小的权重值表示不存在的边
  * 空间需求: $\Theta(|V|^2)$
  * 适合用于稠密图, 即$|E|=\Theta(|V|^2)$
* 邻接表(adjacency list): 通常使用一个数组保存所有顶点
  * 每个顶点都有一个表, 该表存放所有与其邻接的顶点
    * 若边有权重, 同样在表中存放
  * 空间需求: $O(|E|+|V|)$
  * 适合用于稀疏图

说明:  

* 在大部分实际应用中, 顶点都有名字, 而不是数字; 因此必须提供从名字到数字的映射, 而最容易的方法是使用散列表
  * 在散列表中为每个顶点存储其名字和一个内部分配的编号
    * 内部编号是在$1\sim|V|$之间的整数
  * 在每条边被输入时, 检查边的两个顶点在散列表中; 若在, 则使用对应的编号; 若不在, 则为其分配一个可用的编号, 并将名字和编号插入到散列表中
* 在经过这样的变换后, 所有图论算法可以只使用内部编号(整数)

# 2. 拓扑排序Topological sort

拓扑顺序(Topological ordering), 是一种在有向无圈图中的顶点顺序

* 具体是: 若存在一条路径从顶点$v_i$到$v_j$, 那么在拓扑顺序中$v_j$出现在$v_i$后面
* 注意: 
  * 若图中存在圈, 则不可能有拓扑顺序
  * 在有向无圈图中可能有多种拓扑顺序

一种寻找拓扑顺序的算法

* 查找任一没有*入边*(incoming edge)的顶点
* 输出该顶点后, 从图中移除它和与其相关的边
* 重复以上步骤, 直至图为空

入度(indegree), 是指顶点$v$的入边$(u,v)$的数量

* 入度为0的顶点, 就是没有入边的顶点

伪代码实现1: 

* 假设: `Indegree`数组被初始化, 图被读入一个邻接表, `TopNum`数组存放已分配的拓扑编号
  * 在实际中, 通常是将顶点的入度存放在表示顶点的数据结构中, 这是更方便的做法
* `FindNewVertexOfIndegreeZero()`函数: 简单扫描整个`Indegree`数组以寻找一个尚未被分配拓扑编号的入度为0的顶点; 若找不到, 返回`NotAVerex`

```c
void TopSort(Graph G)
{
    int Counter;
    Vertex V, W;
    for (Counter = 0; Counter < NumVertex; Counter++) {
        V = FindNewVertexOfIndegreeZero();
        if (V == NotAVertex) {
            Error("Graph has a cycle");
            break;
        }
        TopNum[V] = Counter;
        for each W adjacent to V
            Indegree[W]--;
    }
}
```

* 可见: 
  * 每次调用`FindNewVertexOfIndegreeZero()`函数需要`O(|V|)`时间
  * 算法的运行时间是$O(|V|^2)$

伪代码实现2: 更好的实现

* 假设`Indegree`数组被初始化且图被读入一个邻接表, `TopNum`数组存放已分配的拓扑编号
* 在初始时使用一个栈或队列存放入度为0的顶点, 并且在移除顶点时维护

```c
void TopSort(Graph G)
{
	Queue Q;
    int Counter = 0;
    Vertex V, W;
    
    Q = CreataQueue(NumVertex); MakeEmpty(Q);
    for each vertex V
        if (Indegree[V] == 0)
            Enqueue(V, Q);
    
    while (!IsEmpty(Q)) {
        V = Dequeue(Q);
        TopNum[V] = ++Counter;
        
        for each W adjacent to V
            if (--Indegree[W] == 0)
                Enqueue(W, Q);
    }
    
    if (Counter != NumVertex)
        Error("Graph has a cycle");
    
    DisposeQueue(Q);
}
```

* 可见: 算法的运行时间是$O(|E|+|V|)$

# 3. 最短路径算法

> 总结: 几种最短路径问题和对应的算法
>
> * 单源最短无权路径问题: 广度优先搜索算法, $O(|E|+|V|)$
> * 单源最短赋权路径问题(没有负权重边的情形): Dijkstra算法, $O(|E|\log_2|V|)$
> * 单源最短赋权路径问题(有负权重边的情形): 广度优先搜索+Dijkstra算法, ($O(|E|\cdot |V|)$
> * 单源最短赋权路径问题(无圈图的情形): 拓扑顺序选取原则的Dijkstra算法, $O(|E|+|V|)$

本节讨论最短路径问题

* 输入是一个赋权图, 它的每条边$(v_i,v_j)$都有成本$c_{i,j}$
  * 对于输入是无权图, 可以看作是赋权图的一种特别情况, 即边的成本都相同, 可都设为1
* 路径$v_1v_2...v_N$的成本是$\sum_{i=1}^{N-1}c_{i,j}+1$

单源最短路径问题(single-source shortest-path problem)

* 给定一个权重图$G=(V,E)$和一个特定顶点$s$, 寻找一条最短的赋权路径(或无权路径), 该路径是从$s$到其他所有可达的顶点
* 在没有负成本圈时, 从顶点$s$到它自身的最短路径长是0

负成本圈(negative-cost cycle)

* 是指图中长度为负的圈
* 若图中存在负成本圈, 最短路径是未定义的

## 最短无权路径问题

最短无权路径问题

* 给定一个无权图$G=(V,E)$和一个特定顶点$s$, 寻找一条最短无权路径, 该路径是从$s$到其他所有可达的顶点

广度优先搜索(breadth-first search), 类似于树的层序遍历

* 从给定顶点$s$开始, 按层处理顶点
* 即: 先处理离$s$最近的顶点, 最后处理最远的顶点

假设: 使用一个数组$T$, 为每个顶点存放三种信息: 

* $d_v$, `Dist`: 表示与$s$的距离; 顶点$s$的$Dist$初始值为0,其他顶点的$Dist$初始值是一个不可达到的值, 如`Infinity`
* $p_v$, `Path`: 最后一个使得`Dist`改变的顶点
  * 这使得能够打印出实际路径; 给出某个目的地顶点, 可沿着`Path`向上查找, 得到整个路径
* `Known`: 当某个顶点被确定其最短路径后, 设`Known`为`true`; 所有顶点的`Known`初始值为`flase`, 表示未确定

伪代码实现1

```c
void Unweighted(Table T)
{
    int CurrDist;
    Vertex V, W;
    for (CurrDist = 0; CurrDist < NumVertex; CurrDist++) {
        for each vertex V
            if (!T[V].Known && T[V].Dist == CurrDist) {
                T[V].Known = True;
                for each W adjacent to V
                    if (T[W].Dist == Infinity) {
                        T[W].Dist = CurrDist + 1;
                        T[W].Path = V;
                    }
            }
    }
}
```

* 算法是$O(|V|^2)$; 原因是双层嵌套循环

伪代码实现2: 进行类似拓扑排序的优化: 

```c
void Unweighted(Table T)
{
    Queue Q;
    Vertex V, W;
    
    Q = CreateQueue(NumVertex); MakeEmpty(Q);
    
    Enqueue(S, Q);
    
    while (!IsEmpty(Q)) {
    	V = Dequeue(Q);
        T[V].Known =  True;
        
        for each W adjacent to V
            if (T[W].Dist == Infinity) {
                T[W].Dist = T[V].Dist + 1;
                T[W].Path = V;
                Enqueue(W, Q);
            }
	}	
    DisposeQueue(Q);
}
```

* 在此实现中, 可以去掉`Known`域
* 算法是$O(|E|+|V|)$

## 最短赋权路径问题(没有负权重边的情形)

最短赋权路径问题(没有负权重边的情形)

* 给定一个没有负权重边的赋权图$G=(V,E)$和一个特定顶点$s$, 寻找一条最短赋权路径, 该路径是从$s$到其他所有可达的顶点

假设: 使用一个数组$T$, 为每个顶点存放三种信息: 

* $d_v$, `Dist`: 表示与$s$的距离; 顶点$s$的$Dist$初始值为0,其他顶点的$Dist$初始值是一个不可达到的值, 如`Infinity`
* $p_v$, `Path`: 最后一个使得`Dist`改变的顶点
  * 这使得能够打印出实际路径; 给出某个目的地顶点, 可沿着`Path`向上查找, 得到整个路径
* `Known`: 当某个顶点被确定其最短路径后, 设`Known`为`true`; 所有顶点的`Known`初始值为`flase`, 表示未确定

Dijkstra算法, 是贪婪算法中的典例 

* 初始阶段, 未确定的最小顶点是$s$
* 在每个阶段, 从所有未确定的顶点中选择一个$d_v$值最小的顶点$v$, 确定从$s$到$v$的最短路径
  * 若有多个$d_v$值最小的顶点, 则随意选取一个, 如总是选择第一个
* 然后, 根据刚确定的顶点$v$, 计算出其他未确定的邻接顶点的$d_v$新值; 若新值更小, 则更新
* 说明: Dijkstra算法不能工作在有负权重边的图中

伪代码实现

```c
typedef int Vertex;
struct TableEntry
{
    List Header;	// Adjacency list
    int Known;
    DistType Dist;
    Vertex Path;
}

// Vertices are nubmered from 0
#define NoeAVertex (-1)
typedef struct TableEntry Table[NumVertex];

void InitTable(Vertex Start, Graph G, Table T)
{
    int i;
    
    ReadGraph(G, T); // Read Graph somehow
    for (i = 0; i < NumVertex; i++) {
        T[i].Known = False;
        T[i].Dist = Infinity;
        T[i].Path = NotAVertex;
    }
    T[Start].Dist = 0;
}

void Dijkstra(Table T)
{
    Vertex V, W;
    
    for (;;) {
        V = smallest unknown distance vertex;
        if (V == NotAVertex)
            break;
        
        T[V].Known = True;
        for each W adjacent to V
            if (!T[W].Known)
                if (T[V].Dist + CostVW < T[w].Dist) {
                    // Update W
                    Decrease(T[W].Dist to
                             T[V].Dist + CostVW);
                    T[W].Path = V;
                }
    }
}
```

* `Dijkstra`函数就是Dijkstra算法的代码实现;
* 分析:
  * 由于每条边最多有一次更新, 在整个算法过程中最多有$|E|$次更新
    * 对于稠密图, 边数$|E|=\Theta(|V|^2)$
    * 对于稀疏图, 边数$|E|=\Theta(|V|)$
  * 若通过**扫描表**来找出$d_v$最小值, 则每次找最小值花费$O(|V|)$, 从而整个算法过程中花费$O(|V|^2)$; 此时, 更新部分是通过**访问数组**进行的, 每次更新需要常数时间, 从而整个算法过程中花费$O(|E|)$; 因此, 算法的总运行时间为$O(|E|+|V|^2)=O(|V|^2)$
    * 对于稠密图, 运行时间与边数$|E|$成线性关系, 该算法既简单且基本上最优
    * 对于稀疏图, 太慢了, 运行时间与边数$|E|$成二次方关系
  * 使用一个额外的优先队列存放顶点的$d_v$值: 两种方法p302, 使得算法的运行时间为$O(|E|\log_2|V|)$
    * 稀疏图使用这种实现
    * 若使用斐波那契堆, 可得$O(|E|+|V|\log_2|V|)$运行时间的算法

## 最短赋权路径问题(有负权重边的情形)

最短赋权路径问题(有负权重边的情形)

* 给定一个赋权图$G=(V,E)$和一个特定顶点$s$, 寻找一条最短赋权路径, 该路径是从$s$到其他所有可达的顶点

一种看似有效的解决思路: 为每个边的权重加上一个常数$\Delta$, 使得所有权重值为正; 然后计算新图的最短路径问题, 最后把结构用到原来的图上

* 问题: 一些具有许多边的路径会变得比那些边比较少的路径的权重更重; 如有三条边的路径的权重增加$3\Delta$, 而只有一条边的路径增加$\Delta$

广度优先搜索+Dijastra算法

* 初始时, 将顶点$s$放入一个队列中
* 在每个阶段, 从队列中dequeue(出队)一个顶点$v$
  * 在所有与$v$邻接的顶点中, 找出所有满足$d_w\gt d_v+c_{v,w}$的顶点$w$
  * 更新$d_w$和$p_w$
  * 若顶点$w$不在队列中, 将其放入队列; (可以为每个顶点设置一个比特位以指示它是否在队列中)
* 重复如此, 直到队列为空

伪代码实现

```c
void WeightedNegative(Table T)
{
    Queue Q;
    Vertex V, W;
    
    Q = CreateQueue(NumVertex); MakeEmpty(Q);
    Enqueue(S, Q);
    
    while (!IsEmpty(Q)) {
        V = Dequeue(Q);
        for each W adjacent to V
            if (T[V].Dist + CostVW < T[W].Dist) {
                // Update W
                T[W].Dist = T[V].Dist + CostVW;
                T[W].Path = V;
                if (W is not already in Q)
                    Enqueue(W, Q);
            }
    }
    DisposeQueue(Q);
}
```

* 每个顶点最多可以出队(dequeue)$|V|$次; 因此, 运行时间是$O(|E|\cdot|V|)$, 若使用邻接表的话
* 在图中没有负成本圈时, 该算法才能正常工作
* 记录顶点的出队次数; 若某个顶点的出队次数达到$|V|+1$次, 则说明存在负成本圈, 此时终止执行该算法

## 最短赋权路径问题(无圈图的情形)

最短赋权路径问题(无圈图的情形)

* 给定一个无圈赋权图$G=(V,E)$和一个特定顶点$s$, 寻找一条最短赋权路径, 该路径是从$s$到其他所有可达的顶点

改进的Dijkstra算法

* 不同之处: 由于无圈图, 能以拓扑顺序选取顶点, 而不是选取最小$d_v$的顶点
* 在进行拓扑排序的同时可以进行选择和更新, 因此该算法只需一次遍历
* 分析:
  * 选取一个顶点需要$O(1)$时间, 因此总运行时间为$O(|V|)$
  * 更新顶点的信息需要$O(1)$时间, 因此总运行时间为$O(|E|)$
  * 算法的总运行时间为$O(|E|+|V|)$

无圈图的应用: 

* 不可逆化学反应: 顶点是该实验的某个特定状态, 边代表从一种状态到另一种状态的转变, 边的权重可以表示释放的能量
* 关键路径分析(critical path analysis): p305
  * 活动节点图(activity-node graph): 顶点表示一个必须执行的活动, 包含完成该活动的时间; 边表示优先关系, 如$(v,w)$表示在开始执行活动$w$前必须完成活动$v$
  * 事件节点图(event-node graph): 顶点表示一件事件, 代表某个活动及其所依赖的活动已经完成; 边表示优先关系; 事件节点图是根据活动节点图得到
  * 根据事件节点图, 可得:
    * 项目的最早完成时间
    * 在不影响最早完成时间的前提下, 某个事件的最晚完成时间

## 所有点对的最短路径

问题: 找出图中所有顶点之间的最短路径

方法: 

* 运行$|V|$次适当的单源算法
* 对于稠密图, 第11章有一种$O(|V|^3)$的算法, 在实践中可能会更快

# 4. 网络流问题

假设:

* 给定有向图$G=(V,E)$, 其中每条边的容量为$c_{v,w}$, 一个发点(source)$s$和一个收点(sink)$t$
* 对于每条边$(v,w)$, 最多有$c_{v,w}$单位的流(flow)可以经过该边; 在每个不是$s$或$t$的顶点$v$, 流入总量等于流出总量
  * 顶点能以任何方式结合分发它的流, 只要边的容量足够和流入量等流出量



最大流量问题

* 确定从$s$到$t$可以通过的最大流量



一种简单的算法: 按阶段处理

* 从图$G$开始, 构造一个流图(flow graph)$G_f$, $G_f$用于表示在任一阶段中已经达到的流; 初始时, $G_f$的所有边都没有流

* 还构造一个残余图(residual graph)$G_r$, 表示每条边还能容纳多大的流, 可以从容量减去当前流得到; $G_r$的边叫做残余边(residual edge)

* 在每个阶段, 从$G_r$寻找一条从$s$到$t$的增长路径(augmenting path); 在该路径上的最小值边的剩余容量, 是可以添加到路径上所有边的流量. 通过调整$G_f$和重新计算$G_r$, 使得该路径添加到$G_f$中
  
* 若无法从$G_r$中找到增长路径, 终止算法
  
* 问题: 该算法是不确定的(nondeterministic), 因为从$s$到$t$的路径是任意选择的; 明显有些选择优于另外一些选择; 所以, 有时候算法不能找到最优解

  * 解决方法: 允许算法执行过程中可以改变主意; 具体是, 对于在流图$G_f$中每条有流$f_{v,w}$的边$(v,w)$, 都有在残余图中添加一条相反的边$(w,v)$, 有相同的流$f_{v,w}$
  * 可以证明, 如果边的容量是有理数, 那么使用上述方法时算法总能以最大流终止; 证明超出本书范围

* 选取增长路径

  * 无要求: 
    * 寻找增长路径使用$O(|E|)$的最短无权路径算法
    * 若容量都是整数, 且最大流为$f$, 因为每次增长路径使得流的值至少增大1, 所以最多有$f$个阶段; 
    * 因此, 算法总运行时间为$O(f\cdot|E|)$

  * 选取流增长最大的增长路径: $O(|E|^2\log_2|V|\log_2{cap_{max}})$, 其中$cap_{max}$是边容量中的最大值
  * 选取最少边数的增长路径: $O(|E|^2\cdot|V|)$

# 5. 最小生成树

生成树

* 连通图$G$的生成树, 是包含$G$所有顶点的无圈子图
  * "树", 是指无圈的
  * "生成", 是指包含所有顶点
* 当且仅当图$G$是连通的, 生成树才存在
  * 对于图的连通性, 可以使用并查集等方法检查
* 生成树中的边是$|V|-1$; 若向生成树添加其他边, 则产生一个圈

最小生成树(minimum spanning tree)

* 无向图$G$的最小生成树, 是指边的总成本最低的生成树

问题:

* 在无向图中找出一个最小生成树
  * 在有向图中有相同的问题, 不过在这里不会讲解

假设: 图$G$是连通的

若在构建生成树时, 在不产生圈的前提下选取成本最低的边, 则构建一个最小生成树

## 普里姆算法Prim's Algorithm

Prim算法, 贪婪算法的典型例子之一

* 初始阶段, 选取一个顶点作为根节点
* 每个阶段, 向树$T$中添加一条边$(u,v)$和一个节点$v$; 边$(u,v)$满足以下条件
  1. 顶点$u$是处于树内, 而顶点$v$是处于树外的
  2. 边$(u,v)$是满足条件1的边中成本最小的

* 说明
  * 本质上, Prim算法是与Dijkstra算法一样的

实现细节:

* 使用一个数组, 为每个顶点保存以下信息
  * $d_v$: 与已确定的顶点之间最短边的成本
  * $p_v$: 最后一个导致$d_v$改变的顶点
  * 一个指标: 标示该顶点是否已确定(known)为树的一部分
* 更新规则: 在一个顶点$v$被确定后, 所有与$v$邻接的未确定顶点$w$的$d_w=min(d_w,c_{w,v})$

## 克鲁斯卡尔算法Kruskal's Algorithm

Kruskal算法, 贪婪算法的典型例子之一

* 策略: 按照最小权重, 连续选取边; 若所选的边不会产生圈, 则接受它

* 基本过程: 使用类似并查集的数据结构

  1. 初始时, 有$|V|$个只有单节点的集合; (每个集合可以看作一棵单节点树)

  2. 按照最小权重选取一条边$(u,v)$, 判断该边是否会产生圈: 两个顶点$u$和$v$同一个集合(同一棵树)
     * 两个顶点属于同一个集合, 当且仅当两个顶点在当前森林中是连通; 由于两个顶点本来是连通的, 若再添加边$(v,w)$, 则会产生圈

  3. 若两个顶点$u$和$v$在同一集合中时, 将会拒绝边$(v,w)$的添加; 否则会接受它, 并在包含$u$和$v$的两个集合上使用归并操作
  4. 重复2,3步骤直至剩下一棵树

* 为了便于选取边, 可以将边进行排序; 更好的主意是构建一个堆, 因为在算法终止前通常只有一小部分的边需要测试

分析:

* 最坏情况下的运行时间为$O(|E|\log_2|E|)$, 取决于堆操作的快慢
  * 由于$|E|=O(|V|^2)$, 这运行时间实际上为$O(|E|\log_2|V|)$
* 在实际中, 该算法会比这时间边界所指示的时间快得多

伪代码

```c
void Kruskal(Graph G)
{
    int EdgesAccepted;
    DisjSet S;
    PriorityQueue H;
    Vertex U,V;
    SetType Uset, Vset;
    Edge E;
    
    Initialize(S);
    ReadGraphIntoHeapArray(G,H);
    BuildHeap(H);
    
    EdgesAccepted = 0;
    while (EdgesAccepted < NumVertex - 1) {
        E = DeletedMin(H); // E = (U,V)
        Uset = Find(U, S);
        Vset = Find(V, S);
        if (Uset != Vset) {
            EdgesAccepted++;
            SetUnion(S, Uset, Vset);
        }
    }
}
```

# 6. 深度优先搜索的应用

深度优先搜索(Depth-first search, DFS), 是先序遍历的推广

* 过程: 从顶点$v$开始, 处理$v$然后递归地遍历所有与$v$邻接的顶点

* 在一棵树执行DFS, 花费$O(|E|)$时间访问所有顶点; 因为树的顶点数$|E|=\Theta(|V|)$
* 在图中执行DFS时, 由于可能有圈, 顶点需要一个标识以表示已访问; 以下伪代码是无向图的DFS算法模板

```c
void Dfs(Vertex V)
{
    Visited[V] = True;
    for each W adjacent to V
        if (!Visited[W]) {
            do something;
            Dfs(W);
        }
}
```

## 无向图与DFS

某无向图$G$是连通的, 当且仅当从任一节点开始的DFS能够访问到每个节点

* 若$G$不是连通的, 该测试能够找出所有连通分量(connected component)

深度优先生成树(depth-first spanning tree)

* 使用DFS得到的生成树
* 在处理边$(v,w)$时发现顶点$w$未被标记时, 用树的一条边表示它
* 在处理边$(v,w)$时发现顶点$w$已被标记时, 且两点间在树中没有边, 那么在树中使用虚线表示, 称之为背向边(back edge)
  * 背向边不是树的一部分, 只是用于辅助

### 无向图的双连通性

无向连通图的双连通性(biconnection)

* 在图中的任一顶点被移除后, 剩下的图仍然是连通的

割点(articulation point)

* 在不是双连通的图中, 那些被删除后图将不再连通的顶点

DFS提供一种算法, 能够在线性时间内在连通图中找出所有割点

* 过程:
  * 从任一顶点开始执行DFS, 并在访问后为其编号
    * 每个顶点$v$的先序编号(preorder number)为$Num(v)$
  * 然后, 为在深度优先生成树中的每个顶点$v$, 计算得出编号最低的顶点, 称之为$Low(v)$; 该顶点对于$v$是可达的, 两顶点之间有零条或多条边, 和零条或一条背向边
    * 根据$Low(v)$的定义, $Low(v)$是以下中的最小值
      * $Num(v)$: 不选取边的情形
      * 在所有可达的背向边$(v,w)$中的最低$Num(w)$: 不选取边而只选取一条背向边的情形
      * 在所有可达的树边$(v,w)$中的最低$Low(w)$: 选取一些边和一条可能的背向边的情形
    * 后序遍历深度优先生成树: 在遍历过程中, 对于每个顶点$v$, $Low(v)$是以下中的最小值
      * $Num(v)$
      * 若有背向边$(v,w)$时, $Num(w)$
      * 若有树的边$(v,w)$时, $Low(w)$
  * 最后, 进行以下判断
    * 根节点是否有多于一个子节点; 若是, 根节点是割点
    * 其他节点$v$是否有满足$Low(w)\ge Num(v)$的子节点; 若是, 该节点是割点
      * 根节点总是有满足$Low(w)\ge Num(v)$的子节点; 所以, 需要进行特别的测试

* 伪代码: 为了更好展示程序的逻辑, 不考虑程序设计的问题

  * 假设有全局数组`Visited[]`(初始化为`false`), `Num[]`, `Low[]`, `Parent[]`
  * 假设有一个全局变量`Counter`, 初始为1

  ```c
  void AssignNum(Vertex V)
  {
      Vertex W;
      
      Num[V] = Counter++;
      Visited[V] = True;
      for each W adjacent to V
          if (!Visited[W]) {
              Parent[W] = V;
              AssignNum(W);
          }
  }
  
  void AssignLow(Vertex V)
  {
      Vertex W;
      
      Low[V] = Num[V];
      for each W adjacent to V {
          if (Num[W] > Num[V]) {
              AssginLow(W);
              if (Low[W] >= Num[V])
                  printf("%v is an articulation point\n", V);
              Low[V] = Min(Low[V], Low[W]);
          } else if (Parent[V] != W)
              Low[V] = Min(Low[V], Num[W]);
      }
  }
  
  //将上述两个函数整合在一起
  void FindArt(Vertex v)
  {
      Veretx W;
      
      Visited[V] = True;
      Low[V] = Num[V] = Counter++;
      for each W adjacent to V {
          if (!Visited[W]) {
              Parent[W] = V;
              FindArt(W);
              if (Low[W] >= Num[V])
                  printf("%v is an articulation point\n", V);
              Low[V] = Min(Low[V], Low[W]);
          } else if (Parent[V] != W)
             Low[V] = Min(Low[V], Num[W]);
      }
  }
  ```

## 欧拉回路Euler Circuit

欧拉路径(Euler path)

* 图$G$中的一个路径; 该路径包含所有边, 且边恰好出现一次

欧拉回路(Euler circuit)

* 若欧拉路径的第一和最后一个顶点是同一个顶点时, 该路径也称为欧拉回路

欧拉路径问题/欧拉回路问题

* 该图是否有欧拉路径/欧拉回路; 若有, 找出来
* 欧拉回路和欧拉路径虽然有所不同, 但有相同的基本解法

关于欧拉路径/回路的性质

* 欧拉路径的必要条件: 图是连通的, 且奇数度的顶点的数量是2个或0个
* 欧拉回路的充分必要条件: 图是连通的, 且每个顶点的度是偶数(即边的条数是偶数)

寻找欧拉回路的思路: 假设图是连通的, 且顶点的度是偶数

1. 从任意顶点$v$开始, 使用DFS寻找一个回路$c$, 并把路径上的边标记为已确定的
2. 若圈$c$上的顶点有未确定的边, 则从第一这样的顶点$w$开始 ,执行新的DFS寻找另外一个回路; 找到新回路后, 在回路$c$的顶点$w$位置与新回路拼接在一起, 得到新的回路$c$
3. 重复如此, 直至圈$c$上的顶点没有未确定的边

## 有向图与DFS

使用与无向图相同的思路, DFS能够以线性时间遍历有向图

* 若图不是强连通的, 从某个节点开始的DFS会访问不了所有节点; 在这种情况下,  在某个未作标记的节点重新开始, 反复执行DFS, 直至所有节目的都被访问到

在有向图的深度优先生成森林中, 除了树的边, 有三种不属于树的辅助边

* 背向边(back edge): 指向祖先顶点
* 前向边(forward edge): 指向后裔顶点
* 交叉边(cross edge): 指向不直接关联的顶点

DFS在有向图的应用: 

* 检测有向图是否无圈: 一个有向图是无圈的, 当且仅当它没有背向边
* 拓扑排序: 通过深度优先生成森林的后序遍历, 给顶点进行拓扑编号$N,N-1,...,1$
  * 前提: 图是无圈的
  * 对于无向图也是可行的

### 有向图的强连通性

强连通

* 顶点$v,w$是强连通的: 是指在顶点$v,w$之间, 既有从$v$到$w$的路径, 也有从$w$到$v$的路径

* 有向图是强连通的: 是指有向图中任意两个顶点$v,w$是强连通的
* 强连通分量: 在非强连通有向图中的强连通子图

问题: 有向图是否强连通; 若不是, 找出所有强连通分量

做法: 执行两次DFS算法

* 实际上使用一次DFS算法也可以判断强连通性; 不过此处的方法容易理解

过程:

* 首先, 在输入图$G$上执行第一次DFS算法; 在深度优先生成森林中, $G$的顶点是通过后序遍历进行编号的; 然后将反向图$G$的所有边, 得出一个相反的图$G_r$
* 在$G_r$执行第二次DFS算法; 在此次DFS算法中, 每次DFS总是在编号最高的顶点开始; 并会得到另一个深度优先生成森林.
  * 在该森林中, 每棵树都是图$G$的强连通分量

解释原理

* 若顶点$v$和$w$在同一强连通分量中, 图$G$中存在从$v$到$w$的路径和从$w$到$v$的路径; 图$G_r$中也存在.
* 如果顶点$x$是$G_r$的包含顶点$v$的深度优先生成树的根节点, 那么图$G_r$存在从$x$到$v$和从$v$到$x$的路径, 也就是说$x$和$v$在同一强连通分量中; 证明如下: 
  1. 在$G_r$的深度优先生成树中, $v$是$x$的后裔节点; 因此在$G_r$中有一条从$x$到$v$的路径, 从而在$G$中有一条从$v$到$x$的路径
  2. 由于$x$是根节点, $x$比$v$有更高的后序编号; 于是, 在第一次DFS中, 所有处理$v$的工作都在$x$的工作结束前完成; 这意味着两个可能:
     * 在$G$ 中, 两者之间没有路径(排除; 由1可知)
     * 在$G$中存在一条从$x$到$v$的路径
  3. 综上可得证
* 如果两个顶点$v,w$在$G_r$的同一深度优先生成树中, 那么$v$和$w$在同一强连通分量中; 证明如下
  * 设$x$是该深度优先生成树的根节点
  * 根据上面的结论可得, $v$和$x$在同一强连通分量中, $w$和$x$在同一强连通分量中
  * 因此, $v$和$w$在同一强连通分量中

# 7. NP-完全性的介绍

在这章讨论了各种各样的图论问题和解法

* 所有这些问题都有多项式运行时间
* 除了网络流问题, 其他的运行时间要么是线性时间, 要么是比线性多一些($O(|E|\log_2|E|)$)

在本节中, 简要介绍NP-完全问题; 许多重要问题的复杂性是差不多一样的

## 难与易

问题的时间边界: 

* 在度量运行时间时, 运行时间$T$被认为是输入规模$N$的函数, $T = f(N)$
* 一般说来, 不能期望运行时间比线性更好;
  * 因为读取输入就需要线性时间
  * 注意: 有些算法的运行时间是$O(\log_2N)$; 它们要么假定已做某些预处理(如已读取输入或已建立数据结构), 要么是在算术例子中

不可判定问题(undecidable problem)

* 计算机不可能解决任何一件问题; 这些不能够解决的问题, 被称为不可判定问题
* 一个特殊的不可判定问题是停机问题(halting problem): 判断任意一个程序是否能在有限的时间之内结束运行

## NP类

> NP, nondeterministic polynomial-time(非确定型多项式时间)

确定型机器(deterministic machine)

* 在每一时刻都在执行一条指令
* 根据正在执行的指令来决定下一条要执行的指令

非确定型机器(nondeterministic machine)

* 可以选择下一步要执行哪条指令
* 若后面的步骤中有某一步骤会得到解答, 它总能选择正确的步骤

NP类的问题

* 若问题的某一个solution(解)能在多项式时间里验证, 则该问题是NP问题

* 检验一个问题是否NP的简单方法: 用yes/no问题来描述该问题
  * 若在多项式时间内能够确定任一yes实例都是正确的, 该问题是NP的 

## NP完全问题

问题$P_1$能够归约(reduce)成问题$P_2$, 是指

* 存在一种映射, 使得$P_1$的任一实例可以变换成$P_2$的一种实例; $P_2$求解后, 将得到的答案映射成$P_1$的答案
* 例子: 数字(number)以十进制的形式输入到计算器中; 然后十进制数转化成对应的二进制数, 所有的计算都是以二进制进行; 最后, 把二进制形式的答案转化成十进制

问题$P_1$能多项式归约(polynomially reduce)成问题$P_2$

* 是指关于变换的工作能够在多项式时间内完成

NP-hard问题

* 是指比NP问题难的问题
* 若NP问题$P_1$能够多项式归约成问题$P_2$, 则$P_2$问题被称为NP-hard问题

NP完全问题(NP-Compete problem, NPC problem, NPC问题)

* NP完全问题是指既是NP也是NP-hard的问题
* 假设有NP完全问题$P_1$和$NP$问题$P_2$, 若$P_1$能够多项式归约成$P_2$, 那么$P_2$也是NP完全的

* 第一个被证明是NP完全的问题是: 可满足性问题(the satisfiability problem)
  * 可满足性问题的输入是一个布尔表达式, 求解该表达式的赋值变量是否可以一致地用值TRUE或FALSE替换